{\rtf1\ansi\ansicpg1252\cocoartf2706
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Menlo-Regular;\f1\fnil\fcharset0 Menlo-Bold;\f2\fnil\fcharset0 Menlo-Italic;
}
{\colortbl;\red255\green255\blue255;\red199\green221\blue12;\red216\green216\blue216;\red255\green198\blue0;
\red190\green214\blue255;\red210\green82\blue82;\red127\green179\blue71;\red121\green171\blue255;\red239\green192\blue144;
}
{\*\expandedcolortbl;;\csgenericrgb\c78039\c86667\c4706;\csgenericrgb\c84706\c84706\c84706;\csgenericrgb\c100000\c77647\c0;
\csgenericrgb\c74510\c83922\c100000;\csgenericrgb\c82353\c32157\c32157;\csgenericrgb\c49804\c70196\c27843;\csgenericrgb\c47451\c67059\c100000;\csgenericrgb\c93725\c75294\c56471;
}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 /******************************************************************************\cf0 \
\
\cf2  @file sensor.c\cf0 \
\
\cf2  @brief TIMAC 2.0 Sensor Example Application\cf0 \
\
\cf2  Group: WCS LPC\cf0 \
\cf2  Target Device: cc13xx_cc26xx\cf0 \
\
\cf2  ******************************************************************************\cf0 \
\cf2  \cf0 \
\cf2  Copyright (c) 2016-2022, Texas Instruments Incorporated\cf0 \
\cf2  All rights reserved.\cf0 \
\
\cf2  Redistribution and use in source and binary forms, with or without\cf0 \
\cf2  modification, are permitted provided that the following conditions\cf0 \
\cf2  are met:\cf0 \
\
\cf2  *  Redistributions of source code must retain the above copyright\cf0 \
\cf2     notice, this list of conditions and the following disclaimer.\cf0 \
\
\cf2  *  Redistributions in binary form must reproduce the above copyright\cf0 \
\cf2     notice, this list of conditions and the following disclaimer in the\cf0 \
\cf2     documentation and/or other materials provided with the distribution.\cf0 \
\
\cf2  *  Neither the name of Texas Instruments Incorporated nor the names of\cf0 \
\cf2     its contributors may be used to endorse or promote products derived\cf0 \
\cf2     from this software without specific prior written permission.\cf0 \
\
\cf2  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"\cf0 \
\cf2  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\cf0 \
\cf2  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\cf0 \
\cf2  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\cf0 \
\cf2  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\cf0 \
\cf2  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\cf0 \
\cf2  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\cf0 \
\cf2  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\cf0 \
\cf2  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\cf0 \
\cf2  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\cf0 \
\cf2  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\cf0 \
\
\cf2  ******************************************************************************\cf0 \
\cf2  \cf0 \
\cf2  \cf0 \
\cf2  *****************************************************************************/\cf0 \
\
\cf2 /******************************************************************************\cf0 \
\cf2  Includes\cf0 \
\cf2  *****************************************************************************/\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 <string.h>\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 <stdint.h>\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "mac_util.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "api_mac.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "jdllc.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "ssf.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "smsgs.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "sensor.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 <advanced_config.h>\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "ti_154stack_config.h"\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_NATIVE_OAD\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "oad_client.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_NATIVE_OAD */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 <ti/drivers/dpl/ClockP.h>\cf0 \

\f1\b \cf1 #else
\f0\b0 \cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "icall.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "central_display.h"\cf0 \

\f1\b \cf1 #else
\f0\b0 \cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "remote_display.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DMM_CENTRAL */\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "ti_dmm_application_policy.h"\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "sm_commissioning_gatt_profile.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "lpstk/lpstk.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 #ifndef
\f0\b0 \cf3  CUI_DISABLE\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "cui.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* CUI_DISABLE */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DEVICE_TYPE_MSG\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 <ti/devices/DeviceFamily.h>\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "device_type.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DEVICE_TYPE_MSG */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "sm_ti154.h"\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "hal_types.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  MAC_DUTY_CYCLE_CHECKING\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "mac_duty_cycle/mac_duty_cycle.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  MAC_OVERRIDE_TX_DELAY\cf0 \

\f1\b \cf1 #include
\f0\b0 \cf3  \cf4 "mac_api.h"\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Constants and definitions\cf0 \
\cf2  *****************************************************************************/\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(CONFIG_AUTO_START)\cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  defined(AUTO_START)\cf0 \

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 CONFIG_AUTO_START\cf3  1\cf0 \

\f1\b \cf1 #else
\f0\b0 \cf0 \

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 CONFIG_AUTO_START\cf3  0\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* default MSDU Handle \ul rollover\ulnone  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 MSDU_HANDLE_MAX\cf3  0x1F\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul App\ulnone  marker in MSDU handle */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 APP_MARKER_MSDU_HANDLE\cf3  0x80\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul App\ulnone  Message Tracking Mask */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 APP_MASK_MSDU_HANDLE\cf3  0x60\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul App\ulnone  Sensor Data marker for the MSDU handle */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 APP_SENSOR_MSDU_HANDLE\cf3  0x40\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul App\ulnone  tracking response marker for the MSDU handle */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 APP_TRACKRSP_MSDU_HANDLE\cf3  0x20\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul App\ulnone  \ul config\ulnone  response marker for the MSDU handle */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 APP_CONFIGRSP_MSDU_HANDLE\cf3  0x60\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* Reporting Interval \ul Min\ulnone  and Max (in milliseconds) */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 MIN_REPORTING_INTERVAL\cf3  1000\cf0 \

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 MAX_REPORTING_INTERVAL\cf3  360000\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* Polling Interval \ul Min\ulnone  and Max (in milliseconds) */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 MIN_POLLING_INTERVAL\cf3  1000\cf0 \

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 MAX_POLLING_INTERVAL\cf3  10000\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* Blink Time for Identify LED Request (in seconds) */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 IDENTIFY_LED_TIME\cf3  1\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* \ul Inter\ulnone  packet interval in certification test mode */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  CERTIFICATION_TEST_MODE\cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  (((CONFIG_PHY_ID >= APIMAC_MRFSK_STD_PHY_ID_BEGIN) && (CONFIG_PHY_ID <= APIMAC_MRFSK_GENERIC_PHY_ID_BEGIN)) || \\\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ((CONFIG_PHY_ID >= APIMAC_200KBPS_915MHZ_PHY_132) && (CONFIG_PHY_ID <= APIMAC_200KBPS_868MHZ_PHY_133)) || \\\cf0 \
\cf3     (CONFIG_PHY_ID == APIMAC_200KBPS_920MHZ_PHY_136))\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*! Regular Mode */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 CERT_MODE_INTER_PKT_INTERVAL\cf3  50\cf0 \

\f1\b \cf1 #elif
\f0\b0 \cf3  ((CONFIG_PHY_ID >= APIMAC_MRFSK_GENERIC_PHY_ID_BEGIN + 1) && (CONFIG_PHY_ID <= APIMAC_5KBPS_868MHZ_PHY_131))\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*! LRM Mode */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #define
\f0\b0 \cf3  \cf5 CERT_MODE_INTER_PKT_INTERVAL\cf3  300\cf0 \

\f1\b \cf1 #else
\f0\b0 \cf0 \

\f1\b \cf1 #error
\f0\b0 \cf3  \cf4 "PHY ID is wrong."\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Global variables\cf0 \
\cf2  *****************************************************************************/\cf0 \
\cf2 /* MAC's IEEE address. This is only for Sensor */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 extern
\f0\b0 \cf3  \cf6 ApiMac_sAddrExt_t\cf3  ApiMac_extAddr;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* Task pending events */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 uint16_t Sensor_events = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* accumulated total E2E delay */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 uint32_t totalE2EDelaySum = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* saved end to end delay */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 uint32_t endToEndDelay = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*! Sensor statistics */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf6 Smsgs_msgStatsField_t\cf3  Sensor_msgStats =\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 extern
\f0\b0 \cf3  bool initBroadcastMsg;\cf0 \

\f1\b \cf1 extern
\f0\b0 \cf3  bool parentFound;\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  POWER_MEAS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*! Power \ul Meas\ulnone  \ul Stats\ulnone  fields */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 Smsgs_powerMeastatsField_t Sensor_pwrMeasStats =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Local variables\cf0 \
\cf2  *****************************************************************************/\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  *sem;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*! Rejoined flag */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  bool rejoining = false;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*! Collector's address */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  \cf6 ApiMac_sAddr_t\cf3  collectorAddr = \{\cf7 0\cf3 \};\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* Join Time Ticks (used for average join time calculations) */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  uint_fast32_t joinTimeTicks = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /* End to end delay statistics \ul timestamp\ulnone  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  uint32_t startSensorMsgTimeStamp = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*! Device's Outgoing MSDU Handle values */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC uint8_t deviceTxMsduHandle = \cf7 0\cf3 ;\cf0 \
\
\cf3 STATIC \cf6 Smsgs_configReqMsg_t\cf3  configSettings;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(OAD_IMG_A) && !defined(POWER_MEAS)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  \ul Temp\ulnone  Sensor field - valid only if Smsgs_dataFields_tempSensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC \cf6 Smsgs_tempSensorField_t\cf3  tempSensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Light Sensor field - valid only if Smsgs_dataFields_lightSensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC \cf6 Smsgs_lightSensorField_t\cf3  lightSensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Humidity Sensor field - valid only if Smsgs_dataFields_humiditySensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC \cf6 Smsgs_humiditySensorField_t\cf3  humiditySensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Hall Effect Sensor field - valid only if Smsgs_dataFields_hallEffectSensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC Smsgs_hallEffectSensorField_t hallEffectSensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Accelerometer Sensor field - valid only if Smsgs_dataFields_accelSensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC Smsgs_accelSensorField_t accelerometerSensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  BLE Sensor field - valid only if Smsgs_dataFields_bleSensor\cf0 \
\cf2  is set in frameControl.\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC Smsgs_bleSensorField_t bleSensor =\cf0 \
\cf3     \{ \cf7 0\cf3  \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !defined(OAD_IMG_A) && !defined(POWER_MEAS) */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3 STATIC \cf6 Llc_netInfo_t\cf3  parentInfo = \{\cf7 0\cf3 \};\cf0 \
\
\cf3 STATIC uint16_t lastRcvdBroadcastMsgId = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /* variable to store the current setting of auto Request \ul Pib\ulnone  attribute\cf0 \
\cf2  * before it gets modified by SM module, in beacon mode\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  bool currAutoReq = \cf7 0\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 SMMsgs_authMethod_t smAuthMethod = SM_SENSOR_DEFAULT_AUTH_METHOD;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 ApiMac_deviceDescriptor_t cacheddevInfo = \{\cf7 0\cf3 \};\cf0 \
\cf3 Llc_netInfo_t cachedparentInfo = \{\cf7 0\cf3 \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Local function prototypes\cf0 \
\cf2  *****************************************************************************/\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 initializeClocks
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 commStatusIndCB
\f0\b0 \cf3 (\cf6 ApiMac_mlmeCommStatusInd_t\cf3  *\cf8 pCommStatusInd\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 dataCnfCB
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataCnf_t\cf3  *\cf8 pDataCnf\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 dataIndCB
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  uint8_t 
\f1\b \cf5 getMsduHandle
\f0\b0 \cf3 (\cf6 Smsgs_cmdIds_t\cf3  \cf8 msgType\cf3 );\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(OAD_IMG_A) && !defined(POWER_MEAS)\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processSensorMsgEvt
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  bool 
\f1\b \cf5 sendSensorMessage
\f0\b0 \cf3 (\cf6 ApiMac_sAddr_t\cf3  *\cf8 pDstAddr\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                               \cf6 Smsgs_sensorMsg_t\cf3  *\cf8 pMsg\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 readSensors
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !defined(OAD_IMG_A) && !defined(POWER_MEAS) */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  SENSOR_TEST_RAMP_DATA_SIZE && (CERTIFICATION_TEST_MODE || defined(POWER_MEAS))\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  processSensorRampMsgEvt(
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  lpstkAccelerometerTiltCb(
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processConfigRequest
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processBroadcastCtrlMsg
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  bool 
\f1\b \cf5 sendConfigRsp
\f0\b0 \cf3 (\cf6 ApiMac_sAddr_t\cf3  *\cf8 pDstAddr\cf3 , \cf6 Smsgs_configRspMsg_t\cf3  *\cf8 pMsg\cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  uint16_t 
\f1\b \cf5 validateFrameControl
\f0\b0 \cf3 (uint16_t \cf8 frameControl\cf3 );\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  defined(DEVICE_TYPE_MSG)\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  Sensor_sendDeviceTypeResponse(
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DEVICE_TYPE_MSG */\cf0 \
\

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcJoinedCb
\f0\b0 \cf3 (\cf6 ApiMac_deviceDescriptor_t\cf3  *\cf8 pDevInfo\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                           \cf6 Llc_netInfo_t\cf3   *\cf8 pStartedInfo\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcDisassocIndCb
\f0\b0 \cf3 (\cf6 ApiMac_sAddrExt_t\cf3  *\cf8 extAddress\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                                \cf6 ApiMac_disassocateReason_t\cf3  \cf8 reason\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcDisassocCnfCb
\f0\b0 \cf3 (\cf6 ApiMac_sAddrExt_t\cf3  *\cf8 extAddress\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                                \cf6 ApiMac_status_t\cf3  \cf8 status\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcStateChangeCb
\f0\b0 \cf3 (\cf6 Jdllc_states_t\cf3  \cf8 state\cf3 );\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /* Security Manager callback functions */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  smFailCMProcessCb(ApiMac_deviceDescriptor_t *devInfo,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                               bool rxOnIdle, bool keyRefreshment,\cf0 \
\cf3                               SMMsgs_errorCode_t errorCode);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  smSuccessCMProcessCb(ApiMac_deviceDescriptor_t *devInfo,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                                  bool keyRefreshment);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM)\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  macSyncLossCb(ApiMac_mlmeSyncLossInd_t *pSyncLossInd);\cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 // Remote display callback functions\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  setRDAttrCb(RemoteDisplayAttr_t remoteDisplayAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *
\f1\b \cf1 const
\f0\b0 \cf3  value, uint8_t len);\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  getRDAttrCb(RemoteDisplayAttr_t remoteDisplayAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *value, uint8_t len);\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 // Provisioning callback functions\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  provisionConnectCb(
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  provisionDisconnectCb(
\f1\b \cf1 void
\f0\b0 \cf3 );\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  setProvisioningCb(ProvisionAttr_t provisioningAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *
\f1\b \cf1 const
\f0\b0 \cf3  value, uint8_t len);\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  getProvisioningCb(ProvisionAttr_t provisioningAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *value, uint8_t len);\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 // Helper functions\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  swapBytes(uint8_t *arr, uint8_t len);\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !DMM_CENTRAL */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  Sensor_dmmPausePolicyCb(uint16_t pause);\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DMM_OAD */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Callback tables\cf0 \
\cf2  *****************************************************************************/\cf0 \
\
\cf2 /*! API MAC Callback table */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC \cf6 ApiMac_callbacks_t\cf3  Sensor_macCallbacks =\cf0 \
\cf3     \{\cf0 \
\cf3       \cf2 /*! Associate Indicated callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Associate Confirmation callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! \ul Disassociate\ulnone  Indication callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! \ul Disassociate\ulnone  Confirmation callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Beacon Notify Indication callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Orphan Indication callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Scan Confirmation callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Start Confirmation callback */\cf0 \
\cf3       NULL,\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3       \cf2 /*! Sync Loss Indication callback */\cf0 \
\cf3       macSyncLossCb,\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3       \cf2 /*! Sync Loss Indication callback */\cf0 \
\cf3       NULL,\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3       \cf2 /*! Poll Confirm callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! \ul Comm\ulnone  Status Indication callback */\cf0 \
\cf3       
\f1\b \cf1 commStatusIndCB
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /*! Poll Indication Callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Data Confirmation callback */\cf0 \
\cf3       
\f1\b \cf1 dataCnfCB
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /*! Data Indication callback */\cf0 \
\cf3       
\f1\b \cf1 dataIndCB
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /*! Purge Confirm callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! WiSUN \ul Async\ulnone  Indication callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! WiSUN \ul Async\ulnone  Confirmation callback */\cf0 \
\cf3       NULL,\cf0 \
\cf3       \cf2 /*! Unprocessed message callback */\cf0 \
\cf3       NULL\cf0 \
\cf3     \};\cf0 \
\
\cf3 STATIC \cf6 Jdllc_callbacks_t\cf3  jdllcCallbacks =\cf0 \
\cf3     \{\cf0 \
\cf3       \cf2 /*! Network Joined Indication callback */\cf0 \
\cf3       
\f1\b \cf1 jdllcJoinedCb
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /* \ul Disassociation\ulnone  Indication callback */\cf0 \
\cf3       
\f1\b \cf1 jdllcDisassocIndCb
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /* \ul Disassociation\ulnone  Confirm callback */\cf0 \
\cf3       
\f1\b \cf1 jdllcDisassocCnfCb
\f0\b0 \cf3 ,\cf0 \
\cf3       \cf2 /*! State Changed indication callback */\cf0 \
\cf3       
\f1\b \cf1 jdllcStateChangeCb
\f0\b0 \cf0 \
\cf3     \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 STATIC SM_callbacks_t SMCallbacks =\cf0 \
\cf3     \{\cf0 \
\cf3       \cf2 /*! Request \ul passkey\ulnone  callback */\cf0 \
\cf3       Ssf_SmPasskeyEntry,\cf0 \
\cf3       \cf2 /*! Security authentication failed callback */\cf0 \
\cf3       smFailCMProcessCb,\cf0 \
\cf3       \cf2 /* Security authentication successful callback */\cf0 \
\cf3       smSuccessCMProcessCb\cf0 \
\cf3     \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 RemoteDisplay_clientProvisioningtCbs_t provisioning_sensorCbs =\cf0 \
\cf3 \{\cf0 \
\cf3     setProvisioningCb,\cf0 \
\cf3     getProvisioningCb,\cf0 \
\cf3     provisionConnectCb,\cf0 \
\cf3     provisionDisconnectCb\cf0 \
\cf3 \};\cf0 \
\
\cf3 RemoteDisplayCbs_t remoteDisplay_sensorCbs =\cf0 \
\cf3 \{\cf0 \
\cf3     setRDAttrCb,\cf0 \
\cf3     getRDAttrCb\cf0 \
\cf3 \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM && !DMM_CENTRAL */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*********************************************************************\cf0 \
\cf2  * DMM Policy \ul Callbacks\cf0 \ulnone \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  DMMPolicy_AppCbs_t dmmPolicyAppCBs =\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3      Sensor_dmmPausePolicyCb\cf0 \
\cf3 \};\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Public Functions\cf0 \
\cf2  *****************************************************************************/\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Initialize MAC level security for this application.\cf0 \
\cf2  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  Sensor_securityInit(uint32_t frameCounter)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     Ssf_getFrameCounter(NULL, &frameCounter);\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the MAC Security */\cf0 \
\cf3     Jdllc_securityInit(frameCounter, NULL);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Initialize this application.\cf0 \
\
\cf2  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \

\f1\b \cf1 void
\f0\b0 \cf3  Sensor_init(uint8_t macTaskId)\cf0 \

\f1\b \cf1 #else
\f0\b0 \cf0 \

\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 Sensor_init
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf6 ApiMac_deviceDescriptor_t\cf3  \cf5 devInfo\cf3 ;\cf0 \
\cf3     \cf6 Llc_netInfo_t\cf3  \cf5 parentInfo\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     uint32_t \cf5 frameCounter\cf3  = \cf7 0\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the sensor's structures */\cf0 \
\cf3     
\f1\b \cf1 memset
\f0\b0 \cf3 (&configSettings, \cf7 0\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_configReqMsg_t\cf3 ));\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(TEMP_SENSOR)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.frameControl |= Smsgs_dataFields_tempSensor;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  defined(LIGHT_SENSOR)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.frameControl |= Smsgs_dataFields_lightSensor;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  defined(HUMIDITY_SENSOR)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.frameControl |= Smsgs_dataFields_humiditySensor;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.frameControl |= Smsgs_dataFields_humiditySensor   |\cf0 \
\cf3                                    Smsgs_dataFields_lightSensor      |\cf0 \
\cf3                                    Smsgs_dataFields_hallEffectSensor |\cf0 \
\cf3                                    Smsgs_dataFields_accelSensor;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.\cf5 frameControl\cf3  |= 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 ;\cf0 \
\cf3     configSettings.\cf5 frameControl\cf3  |= 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     configSettings.frameControl |= Smsgs_dataFields_bleSensor;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (!CERTIFICATION_TEST_MODE)\cf0 \
\cf3     \{\cf0 \
\cf3         configSettings.\cf5 reportingInterval\cf3  = CONFIG_REPORTING_INTERVAL;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* start back to back data transmission at the earliest */\cf0 \
\cf3         configSettings.\cf5 reportingInterval\cf3  = \cf7 100\cf3 ;\cf0 \
\cf3     \}\cf0 \
\cf3     configSettings.\cf5 pollingInterval\cf3  = CONFIG_POLLING_INTERVAL;\cf0 \
\
\cf3     \cf2 /* Initialize the MAC */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     sem = ApiMac_init(macTaskId, CONFIG_FH_ENABLE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     sem = 
\f1\b \cf1 ApiMac_init
\f0\b0 \cf3 (CONFIG_FH_ENABLE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the Joining Device Logical Link Controller */\cf0 \
\cf3     
\f1\b \cf1 Jdllc_init
\f0\b0 \cf3 (&Sensor_macCallbacks, &jdllcCallbacks);\cf0 \
\
\cf3     \cf2 /* Register the MAC \ul Callbacks\ulnone  */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_registerCallbacks
\f0\b0 \cf3 (&Sensor_macCallbacks);\cf0 \
\
\cf3     \cf2 /* Initialize the platform specific functions */\cf0 \
\cf3     
\f1\b \cf1 Ssf_init
\f0\b0 \cf3 (sem);\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  BLE_START\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /*\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      * NOTE!!\cf0 \
\cf2      * OAD_open() must be called before the LPSTK sensors are initialized because there\cf0 \
\cf2      * is no arbitration between the Flash and Accelerometer SPI writes.\cf0 \
\cf2      * OAD_open() is called in remote_display.c, see RemoteDisplay_init().\cf0 \
\cf2      * Here we refer to BLE OAD, not 15.4 OAD.\cf0 \
\cf2      */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Wait for BLE application to finish initializing the BLE OAD Module */\cf0 \
\cf3     Ssf_PendAppSem();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* BLE_START */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* This initializes all LPSTK's sensors, LEDs, and Buttons */\cf0 \
\cf3     Lpstk_init(sem, lpstkAccelerometerTiltCb);\cf0 \
\
\cf3     \cf2 /* Set up a periodic read for sensors specified by the sensor mask */\cf0 \
\cf3     Lpstk_initSensorReadTimer((Lpstk_SensorMask)(LPSTK_HUMIDITY|\cf0 \
\cf3                                                 LPSTK_TEMPERATURE|\cf0 \
\cf3                                                 LPSTK_LIGHT|\cf0 \
\cf3                                                 \cf2 //LPSTK_HALL_EFFECT\cf0 \
\cf3                                                 LPSTK_ACCELEROMETER),\cf0 \
\cf3                                                 \cf7 2000\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* \ul Intialize\ulnone  the security manager and register \ul callbacks\ulnone  */\cf0 \
\cf3     SM_registerCallback(&SMCallbacks);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_phyCurrentDescriptorId
\f0\i0 \cf3 ,\cf0 \
\cf3                            (uint8_t)CONFIG_PHY_ID);\cf0 \
\
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_channelPage
\f0\i0 \cf3 ,\cf0 \
\cf3                            (uint8_t)CONFIG_CHANNEL_PAGE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 Ssf_getFrameCounter
\f0\b0 \cf3 (NULL, &\cf8 frameCounter\cf3 );\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the MAC Security */\cf0 \
\cf3     Jdllc_securityInit(frameCounter, NULL);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Set the transmit power */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_phyTransmitPowerSigned
\f0\i0 \cf3 ,\cf0 \
\cf3                            (uint8_t)CONFIG_TRANSMIT_POWER);\cf0 \
\cf3     \cf2 /* Set \ul Min\ulnone  BE */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_backoffExponent
\f0\i0 \cf3 ,\cf0 \
\cf3                               (uint8_t)CONFIG_MIN_BE);\cf0 \
\cf3     \cf2 /* Set Max BE */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_maxBackoffExponent
\f0\i0 \cf3 ,\cf0 \
\cf3                               (uint8_t)CONFIG_MAX_BE);\cf0 \
\cf3     \cf2 /* Set MAC MAX CSMA \ul Backoffs\ulnone  */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_maxCsmaBackoffs
\f0\i0 \cf3 ,\cf0 \
\cf3                               (uint8_t)CONFIG_MAC_MAX_CSMA_BACKOFFS);\cf0 \
\cf3     \cf2 /* Set MAC MAX Frame Retries */\cf0 \
\cf3     
\f1\b \cf1 ApiMac_mlmeSetReqUint8
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_maxFrameRetries
\f0\i0 \cf3 ,\cf0 \
\cf3                               (uint8_t)CONFIG_MAX_RETRIES);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FCS_TYPE16\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Set the \ul fcs\ulnone  type */\cf0 \
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_fcsType,\cf0 \
\cf3                            (bool)\cf7 1\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  MAC_DUTY_CYCLE_CHECKING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_dutyCycleEnabled, true);\cf0 \
\cf3     ApiMac_mlmeSetReqUint32(ApiMac_attribute_dutyCycleRegulated,\cf0 \
\cf3                             DUTY_CYCLE_MEAS_PERIOD*MAC_DUTY_CYCLE_THRESHOLD/\cf7 100\cf3 );\cf0 \
\
\cf3     \cf2 /* Critical and limited duty cycle modes unused, set to max\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      * value to avoid entering state */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_mlmeSetReqUint32(ApiMac_attribute_dutyCycleCritical,\cf0 \
\cf3                             UINT32_MAX);\cf0 \
\cf3     ApiMac_mlmeSetReqUint32(ApiMac_attribute_dutyCycleLimited,\cf0 \
\cf3                             UINT32_MAX);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  MAC_OVERRIDE_TX_DELAY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_customMinTxOffEnabled, true);\cf0 \
\cf3     ApiMac_mlmeSetReqUint32(ApiMac_attribute_minTxOffTime,\cf0 \
\cf3                             (uint32_t)MAC_CONFIG_MIN_TX_OFF);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the \ul app\ulnone  clocks */\cf0 \
\cf3     
\f1\b \cf1 initializeClocks
\f0\b0 \cf3 ();\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && defined(USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_registerRDCbs(remoteDisplay_sensorCbs);\cf0 \
\cf3     RemoteDisplay_registerClientProvCbs(provisioning_sensorCbs);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* BLE_START && USE_DMM */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 Ssf_getNetworkInfo
\f0\b0 \cf3 (&\cf8 devInfo\cf3 , &\cf8 parentInfo\cf3 ) == true)\cf0 \
\cf3     \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Update policy */\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Update Channel Mask to show the previous network channel */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3  (!CONFIG_FH_ENABLE)\cf0 \
\cf3         \{\cf0 \
\cf3             uint8_t \cf5 channelMask\cf3 [APIMAC_154G_CHANNEL_BITMAP_SIZ] = \{\cf7 0\cf3 \};\cf0 \
\cf3             uint8_t \cf5 idx\cf3  = \cf8 parentInfo\cf3 .\cf5 channel\cf3  / \cf7 8\cf3 ;\cf0 \
\cf3             uint8_t \cf5 shift\cf3  = (\cf8 parentInfo\cf3 .\cf5 channel\cf3  % \cf7 8\cf3 );\cf0 \
\cf3             uint8_t \cf5 chan\cf3  = (\cf7 0x01\cf3 ) << \cf8 shift\cf3 ;\cf0 \
\cf3             \cf8 channelMask\cf3 [\cf8 idx\cf3 ] = \cf8 chan\cf3 ;\cf0 \
\cf3             
\f1\b \cf1 Jdllc_setChanMask
\f0\b0 \cf3 (\cf8 channelMask\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         \cf2 /* Start the device */\cf0 \
\cf3         
\f1\b \cf1 Util_setEvent
\f0\b0 \cf3 (&Sensor_events, SENSOR_START_EVT);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3  (CONFIG_AUTO_START)\cf0 \
\cf3     \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Update policy */\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Start the device */\cf0 \
\cf3         
\f1\b \cf1 Util_setEvent
\f0\b0 \cf3 (&Sensor_events, SENSOR_START_EVT);\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Update BLE remote display with initial state, which will trigger a read\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      * of the default JDLLC setting\cf0 \
\cf2      */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && defined(USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_updateSensorJoinState(Jdllc_states_initWaiting);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 // register the \ul app\ulnone  \ul callbacks\cf0 \ulnone \
\cf3     DMMPolicy_registerAppCbs(dmmPolicyAppCBs, DMMPolicy_StackRole_154Sensor);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Application task processing.\cf0 \
\
\cf2  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 Sensor_process
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf2 /* Start the collector device in the network */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_START_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf6 ApiMac_deviceDescriptor_t\cf3  \cf5 devInfo\cf3 ;\cf0 \
\cf3         \cf6 Llc_netInfo_t\cf3  \cf5 parentInfo\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         uint32_t frameCounter = \cf7 0\cf3 ;\cf0 \
\
\cf3         \cf2 /* update policy */\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\
\cf3         Sensor_securityInit(frameCounter);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 Ssf_getNetworkInfo
\f0\b0 \cf3 (&\cf8 devInfo\cf3 , &\cf8 parentInfo\cf3 ) == true)\cf0 \
\cf3         \{\cf0 \
\cf3             rejoining = true;\cf0 \
\
\cf3             \cf6 Ssf_configSettings_t\cf3  \cf5 configInfo\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             ApiMac_status_t stat;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3             \cf2 /* Do we have \ul config\ulnone  settings? */\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 Ssf_getConfigInfo
\f0\b0 \cf3 (&\cf8 configInfo\cf3 ) == true)\cf0 \
\cf3             \{\cf0 \
\cf3                 \cf2 /* Save the \ul config\ulnone  information */\cf0 \
\cf3                 configSettings.\cf5 frameControl\cf3  = \cf8 configInfo\cf3 .\cf5 frameControl\cf3 ;\cf0 \
\cf3                 configSettings.\cf5 reportingInterval\cf3  = \cf8 configInfo\cf3 .\cf5 reportingInterval\cf3 ;\cf0 \
\cf3                 configSettings.\cf5 pollingInterval\cf3  = \cf8 configInfo\cf3 .\cf5 pollingInterval\cf3 ;\cf0 \
\
\cf3                 \cf2 /* Update the polling interval in the LLC */\cf0 \
\cf3                 
\f1\b \cf1 Jdllc_setPollRate
\f0\b0 \cf3 (configSettings.\cf5 pollingInterval\cf3 );\cf0 \
\cf3             \}\cf0 \
\
\cf3             \cf2 /* Initially, setup the parent as the collector */\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 parentInfo\cf3 .\cf5 fh\cf3  == true && CONFIG_RX_ON_IDLE)\cf0 \
\cf3             \{\cf0 \
\cf3                 collectorAddr.\cf5 addrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_extended
\f0\i0 \cf3 ;\cf0 \
\cf3                 
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&collectorAddr.\cf5 addr\cf3 .\cf5 extAddr\cf3 ,\cf0 \
\cf3                        \cf8 parentInfo\cf3 .\cf5 devInfo\cf3 .\cf5 extAddress\cf3 , APIMAC_SADDR_EXT_LEN);\cf0 \
\cf3             \}\cf0 \
\cf3             
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3             \{\cf0 \
\cf3                 collectorAddr.\cf5 addrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_short
\f0\i0 \cf3 ;\cf0 \
\cf3                 collectorAddr.\cf5 addr\cf3 .\cf5 shortAddr\cf3  = \cf8 parentInfo\cf3 .\cf5 devInfo\cf3 .\cf5 shortAddress\cf3 ;\cf0 \
\cf3             \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             \cf2 /* Put the parent in the security device list */\cf0 \
\cf3             stat = Jdllc_addSecDevice(parentInfo.devInfo.panID,\cf0 \
\cf3                                       parentInfo.devInfo.shortAddress,\cf0 \
\cf3                                       &parentInfo.devInfo.extAddress, \cf7 0\cf3 );\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (stat != ApiMac_status_success)\cf0 \
\cf3             \{\cf0 \
\cf3                 Ssf_displayError(\cf4 "\ul Auth\ulnone  Error: 0x"\cf3 , (uint8_t)stat);\cf0 \
\cf3             \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (!CONFIG_FH_ENABLE)\cf0 \
\cf3             \{\cf0 \
\cf3                 nvDeviceKeyInfo_t devKeyInfo;\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (Ssf_getDeviceKeyInfo(&devKeyInfo) == TRUE)\cf0 \
\cf3                 \{\cf0 \
\cf3                     SM_recoverKeyInfo(devInfo, parentInfo, devKeyInfo);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                     RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_SUCCESS);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 \}\cf0 \
\
\cf3             \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 Jdllc_rejoin
\f0\b0 \cf3 (&\cf8 devInfo\cf3 , &\cf8 parentInfo\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3         \{\cf0 \
\cf3             \cf2 /* Reset flag when joining a new network */\cf0 \
\cf3             rejoining = false;\cf0 \
\
\cf3             \cf2 /* Get Start \ul Timestamp\ulnone  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             joinTimeTicks = ClockP_getSystemTicks();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             joinTimeTicks = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 ();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 Jdllc_join
\f0\b0 \cf3 ();\cf0 \
\cf3         \}\cf0 \
\
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         
\f1\b \cf1 Util_clearEvent
\f0\b0 \cf3 (&Sensor_events, SENSOR_START_EVT);\cf0 \
\cf3     \}\cf0 \
\
\
\cf3     \cf2 /* Is it time to send the next sensor data message? */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_READING_TIMEOUT_EVT)\cf0 \
\cf3     \{\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(OAD_IMG_A)\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* In certification test mode, back to back data shall be sent */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (!CERTIFICATION_TEST_MODE)\cf0 \
\cf3         \{\cf0 \
\cf3             \cf2 /* Setup for the next message */\cf0 \
\cf3             
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (configSettings.\cf5 reportingInterval\cf3 );\cf0 \
\cf3         \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* if secure Commissioning feature is enabled, read\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2          * sensor data and send it only after the secure\cf0 \
\cf2          * commissioning process is done successfully.\cf0 \
\cf2          * else, do not read and send sensor data.\cf0 \
\cf2          */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (SM_Current_State != SM_CM_InProgress)\cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\
\

\f1\b \cf1 #if
\f0\b0 \cf3  SENSOR_TEST_RAMP_DATA_SIZE && (CERTIFICATION_TEST_MODE || defined(POWER_MEAS))\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         processSensorRampMsgEvt();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* SENSOR_TEST_RAMP_DATA_SIZE */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(POWER_MEAS)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Read sensors */\cf0 \
\cf3         
\f1\b \cf1 readSensors
\f0\b0 \cf3 ();\cf0 \
\
\cf3         \cf2 /* Process Sensor Reading Message Event */\cf0 \
\cf3         
\f1\b \cf1 processSensorMsgEvt
\f0\b0 \cf3 ();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* POWER_MEAS */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 //OAD_IMG_A\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         
\f1\b \cf1 Util_clearEvent
\f0\b0 \cf3 (&Sensor_events, SENSOR_READING_TIMEOUT_EVT);\cf0 \
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(OAD_IMG_A)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_OAD_SEND_RESET_RSP_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         OADClient_processEvent(&Sensor_events);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 //OAD_IMG_A\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DISPLAY_PER_STATS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Is it time to update the PER display? */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_UPDATE_STATS_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         Ssf_displayPerStats(&Sensor_msgStats);\cf0 \
\
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         Util_clearEvent(&Sensor_events, SENSOR_UPDATE_STATS_EVT);\cf0 \
\cf3    \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DISPLAY_PER_STATS */\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Process \ul Launchpad\ulnone  \ul Sensortag\ulnone  specific events */\cf0 \
\cf3     Lpstk_processEvents();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Is it provision start event? */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_PROV_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* update policy */\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         Util_clearEvent(&Sensor_events, SENSOR_PROV_EVT);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM && !(DMM_CENTRAL) */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Is it \ul disassociate\ulnone  event? */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_DISASSOC_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 Jdllc_sendDisassociationRequest
\f0\b0 \cf3 ();\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_IDLE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         
\f1\b \cf1 Util_clearEvent
\f0\b0 \cf3 (&Sensor_events, SENSOR_DISASSOC_EVT);\cf0 \
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_PAUSE_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* Turn off timers to temporarily stop transmissions */\cf0 \
\cf3         Ssf_setPollClock(\cf7 0\cf3 );\cf0 \
\cf3         Ssf_setReadingClock(\cf7 0\cf3 );\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (CONFIG_FH_ENABLE)\cf0 \
\cf3         \{\cf0 \
\cf3             Ssf_setTrickleClock(\cf7 0\cf3 , ApiMac_wisunAsyncFrame_advertisementSolicit);\cf0 \
\cf3             Ssf_setTrickleClock(\cf7 0\cf3 , ApiMac_wisunAsyncFrame_configSolicit);\cf0 \
\cf3         \}\cf0 \
\
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         Util_clearEvent(&Sensor_events, SENSOR_PAUSE_EVT);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events & SENSOR_RESUME_EVT)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* Call SENSOR_START_EVT to re-associate with collector if BLE-OAD fails */\cf0 \
\cf3         Util_setEvent(&Sensor_events, SENSOR_START_EVT);\cf0 \
\
\cf3         \cf2 /* Wake up the application thread when it waits for clock event */\cf0 \
\cf3         Ssf_PostAppSem();\cf0 \
\
\cf3         \cf2 /* Clear the event */\cf0 \
\cf3         Util_clearEvent(&Sensor_events, SENSOR_RESUME_EVT);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DMM_OAD */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Process LLC Events */\cf0 \
\cf3     
\f1\b \cf1 Jdllc_process
\f0\b0 \cf3 ();\cf0 \
\
\cf3     \cf2 /* Allow the Specific functions to process */\cf0 \
\cf3     
\f1\b \cf1 Ssf_processEvents
\f0\b0 \cf3 ();\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Allow the security manager specific functions to process */\cf0 \
\cf3     SM_process();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /*\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      Don't process ApiMac messages until all of the sensor events\cf0 \
\cf2      are processed.\cf0 \
\cf2      */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /*only if there are no sensor events and security manager events to handle*/\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 ((Sensor_events == \cf7 0\cf3 ) && (SM_events == \cf7 0\cf3 ))\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (Sensor_events == \cf7 0\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \{\cf0 \
\cf3         \cf2 /* Wait for response message or events */\cf0 \
\cf3         
\f1\b \cf1 ApiMac_processIncoming
\f0\b0 \cf3 ();\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  TX_POWER_TEST\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 uint32_t txPowerLimitTest = \cf7 0\cf3 ;\cf0 \
\cf3 uint8_t txTestPower1 = \cf7 0\cf3 ;\cf0 \
\cf3 uint8_t txTestPower2 = \cf7 5\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Send MAC data request\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    type - message type\cf0 \
\cf2  * @\ul param\ulnone    pDstAddr - destination address\cf0 \
\cf2  * @\ul param\ulnone    rxOnIdle - true if not a sleepy device\cf0 \
\cf2  * @\ul param\ulnone    \ul len\ulnone  - length of \ul payload\cf0 \ulnone \
\cf2  * @\ul param\ulnone    pData - pointer to the buffer\cf0 \
\cf2  *\cf0 \
\cf2  * @return  true if sent, false if not\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 bool 
\f1\b \cf5 Sensor_sendMsg
\f0\b0 \cf3 (\cf6 Smsgs_cmdIds_t\cf3  \cf8 type\cf3 , \cf6 ApiMac_sAddr_t\cf3  *\cf8 pDstAddr\cf3 ,\cf0 \
\cf3                     bool \cf8 rxOnIdle\cf3 , uint16_t \cf8 len\cf3 , uint8_t *\cf8 pData\cf3 )\cf0 \
\cf3 \{\cf0 \
\cf3     bool \cf5 ret\cf3  = false;\cf0 \
\cf3     \cf2 /* information about the network */\cf0 \
\cf3     \cf6 ApiMac_mcpsDataReq_t\cf3  \cf5 dataReq\cf3 ;\cf0 \
\
\cf3     \cf2 /* \ul Timestamp\ulnone  to compute end to end delay */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     startSensorMsgTimeStamp = ClockP_getSystemTicks();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     startSensorMsgTimeStamp = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 ();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Construct the data request field */\cf0 \
\cf3     
\f1\b \cf1 memset
\f0\b0 \cf3 (&\cf8 dataReq\cf3 , \cf7 0\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataReq_t\cf3 ));\cf0 \
\cf3     
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&\cf8 dataReq\cf3 .\cf5 dstAddr\cf3 , \cf8 pDstAddr\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 ApiMac_sAddr_t\cf3 ));\cf0 \
\
\cf3     \cf2 /* set the correct address mode. */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDstAddr\cf3 ->\cf5 addrMode\cf3  == 
\f2\i \cf9 ApiMac_addrType_extended
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 dataReq\cf3 .\cf5 srcAddrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_extended
\f0\i0 \cf3 ;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 dataReq\cf3 .\cf5 srcAddrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_short
\f0\i0 \cf3 ;\cf0 \
\cf3     \}\cf0 \
\
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (rejoining == true)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* get the new panID from the \ul mac\ulnone  */\cf0 \
\cf3         
\f1\b \cf1 ApiMac_mlmeGetReqUint16
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_panId
\f0\i0 \cf3 ,\cf0 \
\cf3                                 &(parentInfo.\cf5 devInfo\cf3 .\cf5 panID\cf3 ));\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf8 dataReq\cf3 .\cf5 dstPanId\cf3  = parentInfo.\cf5 devInfo\cf3 .\cf5 panID\cf3 ;\cf0 \
\
\cf3     \cf8 dataReq\cf3 .\cf5 msduHandle\cf3  = 
\f1\b \cf1 getMsduHandle
\f0\b0 \cf3 (\cf8 type\cf3 );\cf0 \
\
\cf3     \cf8 dataReq\cf3 .\cf5 txOptions\cf3 .\cf5 ack\cf3  = true;\cf0 \
\
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (CERTIFICATION_TEST_MODE)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 dataReq\cf3 .\cf5 txOptions\cf3 .\cf5 ack\cf3  = false;\cf0 \
\cf3     \}\cf0 \
\
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 rxOnIdle\cf3  == false)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 dataReq\cf3 .\cf5 txOptions\cf3 .\cf5 indirect\cf3  = true;\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf8 dataReq\cf3 .\cf5 msdu\cf3 .\cf5 len\cf3  = \cf8 len\cf3 ;\cf0 \
\cf3     \cf8 dataReq\cf3 .\cf5 msdu\cf3 .\cf5 p\cf3  = \cf8 pData\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 extern
\f0\b0 \cf3  ApiMac_sAddrExt_t ApiMac_extAddr;\cf0 \
\cf3         SM_getSrcDeviceSecurityInfo(ApiMac_extAddr, SM_Sensor_SAddress, &dataReq.sec);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     Jdllc_securityFill(&dataReq.sec);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_sensorData
\f0\i0 \cf3  || \cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_rampdata
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 msgsAttempted\cf3 ++;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_trackingRsp
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 trackingResponseAttempts\cf3 ++;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_configRsp
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 configResponseAttempts\cf3 ++;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  TX_POWER_TEST\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  (txPowerLimitTest % \cf7 2\cf3  == \cf7 0\cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         dataReq.power = txTestPower1;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         dataReq.power = txTestPower2;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Send the message */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 ApiMac_mcpsDataReq
\f0\b0 \cf3 (&\cf8 dataReq\cf3 ) == 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 ret\cf3  = true;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* handle transaction overflow by retrying */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_sensorData
\f0\i0 \cf3  || \cf8 type\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_rampdata
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (configSettings.\cf5 reportingInterval\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  TX_POWER_TEST\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     txPowerLimitTest++;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  (\cf8 ret\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  Send LED Identify Request to collector\cf0 \
\
\cf2  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 Sensor_sendIdentifyLedRequest
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t \cf5 cmdBytes\cf3 [SMSGS_INDENTIFY_LED_REQUEST_MSG_LEN];\cf0 \
\
\cf3     \cf2 /* send the response message directly */\cf0 \
\cf3     \cf8 cmdBytes\cf3 [\cf7 0\cf3 ] = (uint8_t) 
\f2\i \cf9 Smsgs_cmdIds_IdentifyLedReq
\f0\i0 \cf3 ;\cf0 \
\cf3     \cf8 cmdBytes\cf3 [\cf7 1\cf3 ] = (uint8_t) IDENTIFY_LED_TIME;\cf0 \
\cf3     
\f1\b \cf1 Sensor_sendMsg
\f0\b0 \cf3 (
\f2\i \cf9 Smsgs_cmdIds_IdentifyLedReq
\f0\i0 \cf3 ,\cf0 \
\cf3             &collectorAddr, true,\cf0 \
\cf3             SMSGS_INDENTIFY_LED_REQUEST_MSG_LEN,\cf0 \
\cf3             \cf8 cmdBytes\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief Sets the Security Authentication Mode\cf0 \
\cf2  *\cf0 \
\cf2  *  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 extern
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  Sensor_setSmAuthMethod(SMMsgs_authMethod_t authMethod)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     smAuthMethod = authMethod;\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief Gets the Security Authentication Mode\cf0 \
\cf2  *\cf0 \
\cf2  *  Public function defined in sensor.h\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 extern
\f0\b0 \cf3  SMMsgs_authMethod_t Sensor_getSmAuthMethod(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  smAuthMethod;\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /******************************************************************************\cf0 \
\cf2  Local Functions\cf0 \
\cf2  *****************************************************************************/\cf0 \
\
\cf2 /*!\cf0 \
\cf2  * @brief       Initialize the clocks.\cf0 \
\cf2  *\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 initializeClocks
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Initialize the reading clock */\cf0 \
\cf3     
\f1\b \cf1 Ssf_initializeReadingClock
\f0\b0 \cf3 ();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     Ssf_initializeProvisioningClock();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !DMM_CENTRAL */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Process the MAC \ul Comm\ulnone  Status Indication Callback\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       pCommStatusInd - \ul Comm\ulnone  Status indication\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 commStatusIndCB
\f0\b0 \cf3 (\cf6 ApiMac_mlmeCommStatusInd_t\cf3  *\cf8 pCommStatusInd\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint32_t \cf5 stat\cf3 ;\cf0 \
\
\cf3     \cf2 /* Frame received with security error */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  (\cf8 pCommStatusInd\cf3 ->\cf5 reason\cf3  == 
\f2\i \cf9 ApiMac_commStatusReason_rxSecure
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\
\cf3         
\f1\b \cf1 ApiMac_mlmeGetReqUint32
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_diagRxSecureFail
\f0\i0 \cf3 , &\cf8 stat\cf3 );\cf0 \
\cf3         Sensor_msgStats.\cf5 rxDecryptFailures\cf3  = (uint16_t)\cf8 stat\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  MAC_OVERRIDE_TX_DELAY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* Enabling the minimum custom TX off-time feature in SysConfig\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2          * will overwrite ApiMac_attribute_diagTxSecureFail MAC PIB. See\cf0 \
\cf2          * api_mac.c/h\cf0 \
\cf2          */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 ApiMac_mlmeGetReqUint32
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_diagTxSecureFail
\f0\i0 \cf3 , &\cf8 stat\cf3 );\cf0 \
\cf3         Sensor_msgStats.\cf5 txEncryptFailures\cf3  = (uint16_t)\cf8 stat\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 Ssf_displayError
\f0\b0 \cf3 (\cf4 "Security Error: "\cf3 , \cf8 pCommStatusInd\cf3 ->\cf5 status\cf3 );\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      MAC Data Confirm callback.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       pDataCnf - pointer to the data confirm information\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 dataCnfCB
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataCnf_t\cf3  *\cf8 pDataCnf\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\
\cf3     \cf2 /* Record statistics */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_channelAccessFailure
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 channelAccessFailures\cf3 ++;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_noAck
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 macAckFailures\cf3 ++;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DISPLAY_PER_STATS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         Util_setEvent(&Sensor_events, SENSOR_UPDATE_STATS_EVT);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DISPLAY_PER_STATS */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  != 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         Sensor_msgStats.\cf5 otherDataRequestFailures\cf3 ++;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DISPLAY_PER_STATS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         Util_setEvent(&Sensor_events, SENSOR_UPDATE_STATS_EVT);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DISPLAY_PER_STATS */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 Ssf_displayError
\f0\b0 \cf3 (\cf4 "dataCnf: "\cf3 , \cf8 pDataCnf\cf3 ->\cf5 status\cf3 );\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 Ssf_updateFrameCounter
\f0\b0 \cf3 (NULL, \cf8 pDataCnf\cf3 ->\cf5 frameCntr\cf3 );\cf0 \
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Strictly ensure that the message did not come from the \ul app\ulnone  */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (!(pDataCnf->msduHandle & APP_MARKER_MSDU_HANDLE))\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3  ((SM_CM_InProgress == SM_Current_State) && (true == useSendPktStatus))\cf0 \
\cf3         \{\cf0 \
\cf3             \cf2 /* Make sure the message came from the SM module */\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3  (pDataCnf->msduHandle & SM_FAIL_MSDU_HANDLE)\cf0 \
\cf3             \{\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (pDataCnf->status != ApiMac_status_success)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Set an event that failure status from previous packet sent is seen */\cf0 \
\cf3                     Util_setEvent(&SM_events, SM_SEND_PKT_FB_EVT);\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Switch to fail state once fail packet is received */\cf0 \
\cf3                     Util_setEvent(&SM_events, SM_SENT_CM_FAIL_EVT);\cf0 \
\cf3                 \}\cf0 \
\cf3             \}\cf0 \
\cf3             
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (pDataCnf->msduHandle & SM_DATA_MSDU_HANDLE)\cf0 \
\cf3             \{\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (pDataCnf->status != ApiMac_status_success)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Set an event that failure status from previous packet sent is seen */\cf0 \
\cf3                     Util_setEvent(&SM_events, SM_SEND_PKT_FB_EVT);\cf0 \
\cf3                 \}\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Make sure the message came from the \ul app\ulnone  */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 msduHandle\cf3  & APP_MARKER_MSDU_HANDLE)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* What message type was the original request? */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 pDataCnf\cf3 ->\cf5 msduHandle\cf3  & APP_MASK_MSDU_HANDLE)\cf0 \
\cf3            == APP_SENSOR_MSDU_HANDLE)\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 Sensor_msgStats.\cf5 msgsSent\cf3 ++;\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3  (Sensor_msgStats.\cf5 msgsSent\cf3  == \cf7 0\cf3 )\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* the count is wrapped around, set to 1 to avoid divided by zero */\cf0 \
\cf3                     Sensor_msgStats.\cf5 msgsSent\cf3  = \cf7 1\cf3 ;\cf0 \
\cf3                     totalE2EDelaySum = \cf7 0\cf3 ;\cf0 \
\cf3                 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DISPLAY_PER_STATS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 Util_setEvent(&Sensor_events, SENSOR_UPDATE_STATS_EVT);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DISPLAY_PER_STATS */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 \cf2 /* Calculate end to end delay */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (ClockP_getSystemTicks() < startSensorMsgTimeStamp)\cf0 \
\cf3                 \{\cf0 \
\cf3                     endToEndDelay = ClockP_getSystemTicks() +\cf0 \
\cf3                                     (\cf7 0xFFFFFFFF\cf3 -startSensorMsgTimeStamp);\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3                 \{\cf0 \
\cf3                     endToEndDelay = ClockP_getSystemTicks() - startSensorMsgTimeStamp;\cf0 \
\cf3                 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () < startSensorMsgTimeStamp)\cf0 \
\cf3                 \{\cf0 \
\cf3                     endToEndDelay = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () +\cf0 \
\cf3                                     (\cf7 0xFFFFFFFF\cf3 -startSensorMsgTimeStamp);\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3                 \{\cf0 \
\cf3                     endToEndDelay = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () - startSensorMsgTimeStamp;\cf0 \
\cf3                 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 endToEndDelay = endToEndDelay/TICKPERIOD_MS_US;\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3  ( (totalE2EDelaySum + endToEndDelay ) < totalE2EDelaySum)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* totalE2EDelaySum is wrapped around,reset the sent count 1 */\cf0 \
\cf3                     totalE2EDelaySum = endToEndDelay;\cf0 \
\cf3                     Sensor_msgStats.\cf5 msgsSent\cf3  = \cf7 1\cf3 ;\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3                 \{\cf0 \
\cf3                     totalE2EDelaySum += endToEndDelay;\cf0 \
\cf3                 \}\cf0 \
\
\cf3                 Sensor_msgStats.\cf5 worstCaseE2EDelay\cf3  =\cf0 \
\cf3                    (Sensor_msgStats.\cf5 worstCaseE2EDelay\cf3  > endToEndDelay) ?\cf0 \
\cf3                     Sensor_msgStats.\cf5 worstCaseE2EDelay\cf3 :endToEndDelay;\cf0 \
\
\cf3                 Sensor_msgStats.\cf5 avgE2EDelay\cf3 =totalE2EDelaySum/Sensor_msgStats.\cf5 msgsSent\cf3 ;\cf0 \
\
\cf3             \}\cf0 \
\
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  CERTIFICATION_TEST_MODE\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             \{\cf0 \
\cf3                 \cf2 /* Setup for the next message */\cf0 \
\cf3                 Ssf_setReadingClock(CERT_MODE_INTER_PKT_INTERVAL);\cf0 \
\cf3             \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 pDataCnf\cf3 ->\cf5 msduHandle\cf3  & APP_MASK_MSDU_HANDLE)\cf0 \
\cf3            == APP_TRACKRSP_MSDU_HANDLE)\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 Sensor_msgStats.\cf5 trackingResponseSent\cf3 ++;\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 pDataCnf\cf3 ->\cf5 msduHandle\cf3  & APP_MASK_MSDU_HANDLE)\cf0 \
\cf3            == APP_CONFIGRSP_MSDU_HANDLE)\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataCnf\cf3 ->\cf5 status\cf3  == 
\f2\i \cf9 ApiMac_status_success
\f0\i0 \cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 Sensor_msgStats.\cf5 configResponseSent\cf3 ++;\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      MAC Data Indication callback.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       pDataInd - pointer to the data indication information\cf0 \
\cf2  */\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 dataIndCB
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t \cf5 cmdBytes\cf3 [SMSGS_TOGGLE_LED_RESPONSE_MSG_LEN];\cf0 \
\
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 pDataInd\cf3  != NULL) && (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 p\cf3  != NULL)\cf0 \
\cf3        && (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 len\cf3  > \cf7 0\cf3 ))\cf0 \
\cf3     \{\cf0 \
\cf3         \cf6 Smsgs_cmdIds_t\cf3  \cf5 cmdId\cf3  = (\cf6 Smsgs_cmdIds_t\cf3 )*(\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 p\cf3 );\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (Jdllc_securityCheck(&(pDataInd->sec)) == false)\cf0 \
\cf3             \{\cf0 \
\cf3                 \cf2 /* reject the message */\cf0 \
\cf3                 
\f1\b \cf1 return
\f0\b0 \cf3 ;\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 switch
\f0\b0 \cf3 (\cf8 cmdId\cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  
\f2\i \cf9 Smsgs_cmdIds_configReq
\f0\i0 \cf3 :\cf0 \
\cf3                 
\f1\b \cf1 processConfigRequest
\f0\b0 \cf3 (\cf8 pDataInd\cf3 );\cf0 \
\cf3                 Sensor_msgStats.\cf5 configRequests\cf3 ++;\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  
\f2\i \cf9 Smsgs_cmdIds_trackingReq
\f0\i0 \cf3 :\cf0 \
\cf3                 \cf2 /* Make sure the message is the correct size */\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 len\cf3  == SMSGS_TRACKING_REQUEST_MSG_LENGTH)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* only send data if sensor is in the network */\cf0 \
\cf3                     
\f1\b \cf1 if
\f0\b0 \cf3  ((
\f1\b \cf1 Jdllc_getProvState
\f0\b0 \cf3 () == 
\f2\i \cf9 Jdllc_states_joined
\f0\i0 \cf3 ) ||\cf0 \
\cf3                             (
\f1\b \cf1 Jdllc_getProvState
\f0\b0 \cf3 () == 
\f2\i \cf9 Jdllc_states_rejoined
\f0\i0 \cf3 ))\cf0 \
\cf3                     \{\cf0 \
\cf3                         \cf2 /* Update \ul stats\ulnone  */\cf0 \
\cf3                         Sensor_msgStats.\cf5 trackingRequests\cf3 ++;\cf0 \
\
\cf3                         \cf2 /* Indicate tracking message received */\cf0 \
\cf3                         
\f1\b \cf1 Ssf_trackingUpdate
\f0\b0 \cf3 (&\cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 );\cf0 \
\
\cf3                         \cf2 /* send the response message directly */\cf0 \
\cf3                         \cf8 cmdBytes\cf3 [\cf7 0\cf3 ] = (uint8_t) 
\f2\i \cf9 Smsgs_cmdIds_trackingRsp
\f0\i0 \cf3 ;\cf0 \
\
\cf3                         
\f1\b \cf1 Sensor_sendMsg
\f0\b0 \cf3 (
\f2\i \cf9 Smsgs_cmdIds_trackingRsp
\f0\i0 \cf3 ,\cf0 \
\cf3                                            &\cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 , true,\cf0 \
\cf3                                            \cf7 1\cf3 , \cf8 cmdBytes\cf3 );\cf0 \
\cf3                     \}\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  
\f2\i \cf9 Smsgs_cmdIds_toggleLedReq
\f0\i0 \cf3 :\cf0 \
\cf3                 \cf2 /* Make sure the message is the correct size */\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 len\cf3  == SMSGS_TOGGLE_LED_REQUEST_MSG_LEN)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* only send data if sensor is in the network */\cf0 \
\cf3                     
\f1\b \cf1 if
\f0\b0 \cf3  ((
\f1\b \cf1 Jdllc_getProvState
\f0\b0 \cf3 () == 
\f2\i \cf9 Jdllc_states_joined
\f0\i0 \cf3 ) ||\cf0 \
\cf3                             (
\f1\b \cf1 Jdllc_getProvState
\f0\b0 \cf3 () == 
\f2\i \cf9 Jdllc_states_rejoined
\f0\i0 \cf3 ))\cf0 \
\cf3                     \{\cf0 \
\cf3                         \cf2 /* send the response message directly */\cf0 \
\cf3                         \cf8 cmdBytes\cf3 [\cf7 0\cf3 ] = (uint8_t) 
\f2\i \cf9 Smsgs_cmdIds_toggleLedRsp
\f0\i0 \cf3 ;\cf0 \
\cf3                         \cf8 cmdBytes\cf3 [\cf7 1\cf3 ] = 
\f1\b \cf1 Ssf_toggleLED
\f0\b0 \cf3 ();\cf0 \
\cf3                         
\f1\b \cf1 Sensor_sendMsg
\f0\b0 \cf3 (
\f2\i \cf9 Smsgs_cmdIds_toggleLedRsp
\f0\i0 \cf3 ,\cf0 \
\cf3                             &\cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 , true,\cf0 \
\cf3                             SMSGS_TOGGLE_LED_RESPONSE_MSG_LEN,\cf0 \
\cf3                             \cf8 cmdBytes\cf3 );\cf0 \
\cf3                     \}\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  
\f2\i \cf9 Smgs_cmdIds_broadcastCtrlMsg
\f0\i0 \cf3 :\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (parentFound)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Node has successfully associated with the network */\cf0 \
\cf3                     
\f1\b \cf1 processBroadcastCtrlMsg
\f0\b0 \cf3 (\cf8 pDataInd\cf3 );\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  POWER_MEAS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  Smsgs_cmdIds_rampdata:\cf0 \
\cf3                 Sensor_pwrMeasStats.rampDataRcvd++;\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  Smsgs_cmdIds_oad:\cf0 \
\cf3                 \cf2 //Index past the Smsgs_cmdId\cf0 \
\cf3                 OADProtocol_ParseIncoming((
\f1\b \cf1 void
\f0\b0 \cf3 *) &(pDataInd->srcAddr), pDataInd->msdu.p + \cf7 1\cf3 );\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 //FEATURE_NATIVE_OAD\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  Smgs_cmdIds_CommissionStart:\cf0 \
\cf3                 \{\cf0 \
\cf3                     ApiMac_sec_t devSec;\cf0 \
\cf3                     
\f1\b \cf1 extern
\f0\b0 \cf3  ApiMac_sAddrExt_t ApiMac_extAddr;\cf0 \
\
\cf3                     \cf2 /* Obtain MAC level security information. Use network key for SM */\cf0 \
\cf3                     Jdllc_securityFill(&devSec);\cf0 \
\
\cf3                     uint8_t *pBuf = pDataInd->msdu.p;\cf0 \
\cf3                     pBuf += 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_cmdIds_t);\cf0 \
\cf3                     SMMsgs_cmdIds_t CMMsgId = (SMMsgs_cmdIds_t)Util_buildUint16(pBuf[\cf7 0\cf3 ], pBuf[\cf7 1\cf3 ]);\cf0 \
\
\cf3                     \cf2 /* read the current value */\cf0 \
\cf3                     ApiMac_mlmeGetReqBool(ApiMac_attribute_autoRequest, &currAutoReq);\cf0 \
\
\cf3                     \cf2 /* beacon-mode of operation and autoRequest is set to true and sleepy device  */\cf0 \
\cf3                     
\f1\b \cf1 if
\f0\b0 \cf3 ((CONFIG_MAC_BEACON_ORDER != \cf7 15\cf3 ) && (currAutoReq == true) && (!CONFIG_RX_ON_IDLE))\cf0 \
\cf3                     \{\cf0 \
\cf3                         \cf2 /* set autoRequest to false and enable explicit polling */\cf0 \
\cf3                         ApiMac_mlmeSetReqBool(ApiMac_attribute_autoRequest, false);\cf0 \
\cf3                         Util_setEvent(&Jdllc_events, JDLLC_POLL_EVT);\cf0 \
\cf3                     \}\cf0 \
\
\cf3                     
\f1\b \cf1 if
\f0\b0 \cf3  (CMMsgId == SMMsgs_cmdIds_keyRefreshRequest)\cf0 \
\cf3                     \{\cf0 \
\cf3                         
\f1\b \cf1 if
\f0\b0 \cf3 (SM_Current_State != SM_CM_InProgress)\cf0 \
\cf3                         \{\cf0 \
\cf3                             \cf2 /* Kick off key refreshment process if SM state machine is not being run */\cf0 \
\cf3                             SM_startKeyRefreshProcess(&parentInfo.devInfo, &devSec,\cf0 \
\cf3                                                                parentInfo.fh, true);\cf0 \
\cf3                         \}\cf0 \
\cf3                     \}\cf0 \
\cf3                     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (CMMsgId == SMMsgs_cmdIds_processRequest)\cf0 \
\cf3                     \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                         \cf2 /* Kick off commissioning process to obtain security information */\cf0 \
\cf3                         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\cf3                         RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_STARTING);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                         SM_startCMProcess(&parentInfo.devInfo, &devSec, parentInfo.fh,\cf0 \
\cf3                                           true, SM_type_device, smAuthMethod);\cf0 \
\cf3                     \}\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  Smgs_cmdIds_CommissionMsg:\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Process Security manager commissioning data */\cf0 \
\cf3                     SM_processCommData(pDataInd);\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  defined(DEVICE_TYPE_MSG)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 case
\f0\b0 \cf3  Smsgs_cmdIds_DeviceTypeReq:\cf0 \
\cf3                 \cf2 /* Make sure the message is the correct size */\cf0 \
\cf3                 
\f1\b \cf1 if
\f0\b0 \cf3 (pDataInd->msdu.len == SMSGS_DEVICE_TYPE_REQUEST_MSG_LEN)\cf0 \
\cf3                 \{\cf0 \
\cf3                     \cf2 /* Only send data if sensor is in the network */\cf0 \
\cf3                     
\f1\b \cf1 if
\f0\b0 \cf3  ((Jdllc_getProvState() == Jdllc_states_joined) ||\cf0 \
\cf3                             (Jdllc_getProvState() == Jdllc_states_rejoined))\cf0 \
\cf3                     \{\cf0 \
\cf3                         Sensor_sendDeviceTypeResponse();\cf0 \
\cf3                     \}\cf0 \
\cf3                 \}\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DEVICE_TYPE_MSG */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 default
\f0\b0 \cf3 :\cf0 \
\cf3                 \cf2 /* Should not receive other messages */\cf0 \
\cf3                 
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Get the next MSDU Handle\cf0 \
\cf2  *             <BR>\cf0 \
\cf2  *             The MSDU handle has 3 parts:<BR>\cf0 \
\cf2  *             - The MSBit(7), when set means the the application sent the\cf0 \
\cf2  *               message\cf0 \
\cf2  *             - Bit 6, when set means that the \ul app\ulnone  message is a \ul config\ulnone  request\cf0 \
\cf2  *             - Bits 0-5, used as a message counter that rolls over.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       msgType - message command id needed\cf0 \
\cf2  *\cf0 \
\cf2  * @return     \ul msdu\ulnone  Handle\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  uint8_t 
\f1\b \cf5 getMsduHandle
\f0\b0 \cf3 (\cf6 Smsgs_cmdIds_t\cf3  \cf8 msgType\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t \cf5 msduHandle\cf3  = deviceTxMsduHandle;\cf0 \
\
\cf3     \cf2 /* Increment for the next \ul msdu\ulnone  handle, or roll over */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (deviceTxMsduHandle >= MSDU_HANDLE_MAX)\cf0 \
\cf3     \{\cf0 \
\cf3         deviceTxMsduHandle = \cf7 0\cf3 ;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         deviceTxMsduHandle++;\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Add the \ul App\ulnone  specific bit */\cf0 \
\cf3     \cf8 msduHandle\cf3  |= APP_MARKER_MSDU_HANDLE;\cf0 \
\
\cf3     \cf2 /* Add the message type bit */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 msgType\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_sensorData
\f0\i0 \cf3  || \cf8 msgType\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_rampdata
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 msduHandle\cf3  |= APP_SENSOR_MSDU_HANDLE;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 msgType\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_trackingRsp
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 msduHandle\cf3  |= APP_TRACKRSP_MSDU_HANDLE;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 msgType\cf3  == 
\f2\i \cf9 Smsgs_cmdIds_configRsp
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 msduHandle\cf3  |= APP_CONFIGRSP_MSDU_HANDLE;\cf0 \
\cf3     \}\cf0 \
\
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  (\cf8 msduHandle\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  @brief  Build and send fixed size ramp data\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  SENSOR_TEST_RAMP_DATA_SIZE && (CERTIFICATION_TEST_MODE || defined(POWER_MEAS))\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  processSensorRampMsgEvt(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t *pMsgBuf;\cf0 \
\cf3     uint16_t index;\cf0 \
\
\cf3     pMsgBuf = (uint8_t *)Ssf_malloc(SENSOR_TEST_RAMP_DATA_SIZE);\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (pMsgBuf)\cf0 \
\cf3     \{\cf0 \
\cf3         uint8_t *pBuf = pMsgBuf;\cf0 \
\cf3         *pBuf++ = (uint8_t)Smsgs_cmdIds_rampdata;\cf0 \
\cf3         
\f1\b \cf1 for
\f0\b0 \cf3 (index = \cf7 1\cf3 ; index < SENSOR_TEST_RAMP_DATA_SIZE; index++)\cf0 \
\cf3         \{\cf0 \
\cf3             *pBuf++ = (uint8_t) (index & \cf7 0xFF\cf3 );\cf0 \
\cf3         \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(POWER_MEAS) && !defined(USE_DMM)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 //Toggle Sensor reading LED\cf0 \
\cf3         Ssf_sensorReadingUpdate(NULL);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         Sensor_sendMsg(Smsgs_cmdIds_rampdata, &collectorAddr, true,\cf0 \
\cf3                 SENSOR_TEST_RAMP_DATA_SIZE, pMsgBuf);\cf0 \
\
\cf3         Ssf_free(pMsgBuf);\cf0 \
\cf3     \}\cf0 \
\
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  !defined(OAD_IMG_A) && !defined(POWER_MEAS)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  @brief   Build and send sensor data message\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processSensorMsgEvt
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf6 Smsgs_sensorMsg_t\cf3  \cf5 sensor\cf3 ;\cf0 \
\
\cf3     
\f1\b \cf1 memset
\f0\b0 \cf3 (&\cf8 sensor\cf3 , \cf7 0\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_sensorMsg_t\cf3 ));\cf0 \
\
\cf3     
\f1\b \cf1 ApiMac_mlmeGetReqArray
\f0\b0 \cf3 (
\f2\i \cf9 ApiMac_attribute_extendedAddress
\f0\i0 \cf3 ,\cf0 \
\cf3                            \cf8 sensor\cf3 .\cf5 extAddress\cf3 );\cf0 \
\
\cf3     \cf2 /* fill in the message */\cf0 \
\cf3     \cf8 sensor\cf3 .\cf5 frameControl\cf3  = configSettings.\cf5 frameControl\cf3 ;\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 sensor\cf3 .\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_tempSensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&\cf8 sensor\cf3 .\cf5 tempSensor\cf3 , &tempSensor,\cf0 \
\cf3                
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_tempSensorField_t\cf3 ));\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 sensor\cf3 .\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_lightSensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&\cf8 sensor\cf3 .\cf5 lightSensor\cf3 , &lightSensor,\cf0 \
\cf3                
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_lightSensorField_t\cf3 ));\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 sensor\cf3 .\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_humiditySensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&\cf8 sensor\cf3 .\cf5 humiditySensor\cf3 , &humiditySensor,\cf0 \
\cf3                
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_humiditySensorField_t\cf3 ));\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 sensor\cf3 .\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&\cf8 sensor\cf3 .\cf5 msgStats\cf3 , &Sensor_msgStats,\cf0 \
\cf3                
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_msgStatsField_t\cf3 ));\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 sensor\cf3 .\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 sensor\cf3 .\cf5 configSettings\cf3 .\cf5 pollingInterval\cf3  = configSettings.\cf5 pollingInterval\cf3 ;\cf0 \
\cf3         \cf8 sensor\cf3 .\cf5 configSettings\cf3 .\cf5 reportingInterval\cf3  = configSettings\cf0 \
\cf3                         .\cf5 reportingInterval\cf3 ;\cf0 \
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (sensor.frameControl & Smsgs_dataFields_hallEffectSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         sensor.hallEffectSensor.fluxLevel = hallEffectSensor.fluxLevel;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (sensor.frameControl & Smsgs_dataFields_accelSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         memcpy(&sensor.accelerometerSensor, &accelerometerSensor,\cf0 \
\cf3                        
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_accelSensorField_t));\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (sensor.frameControl & Smsgs_dataFields_bleSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         memcpy(&sensor.bleSensor, &bleSensor,\cf0 \
\cf3                                
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_bleSensorField_t));\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* inform the user interface */\cf0 \
\cf3     
\f1\b \cf1 Ssf_sensorReadingUpdate
\f0\b0 \cf3 (&\cf8 sensor\cf3 );\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Sync BLE application with new data */\cf0 \
\cf3     RemoteDisplay_updateSensorData();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* BLE_START && USE_DMM && !(DMM_CENTRAL) */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* send the data to the collector */\cf0 \
\cf3     
\f1\b \cf1 sendSensorMessage
\f0\b0 \cf3 (&collectorAddr, &\cf8 sensor\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Manually read the sensors\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 readSensors
\f0\b0 \cf3 (
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(TEMP_SENSOR)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Read the \ul temp\ulnone  sensor values */\cf0 \
\cf3     tempSensor.ambienceTemp = Ssf_readTempSensor();\cf0 \
\cf3     tempSensor.objectTemp =  tempSensor.ambienceTemp;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     Lpstk_Accelerometer accel;\cf0 \
\cf3     humiditySensor.temp = (uint16_t)Lpstk_getTemperature();\cf0 \
\cf3     humiditySensor.humidity = (uint16_t)Lpstk_getHumidity();\cf0 \
\cf3     hallEffectSensor.fluxLevel = Lpstk_getHallEffectSwitch();\cf0 \
\cf3     lightSensor.rawData = (uint16_t)Lpstk_getLux();\cf0 \
\cf3     Lpstk_getAccelerometer(&accel);\cf0 \
\cf3     accelerometerSensor.xAxis = accel.x;\cf0 \
\cf3     accelerometerSensor.yAxis = accel.y;\cf0 \
\cf3     accelerometerSensor.zAxis = accel.z;\cf0 \
\cf3     accelerometerSensor.xTiltDet = accel.xTiltDet;\cf0 \
\cf3     accelerometerSensor.yTiltDet = accel.yTiltDet;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Build and send sensor data message\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pDstAddr - Where to send the message\cf0 \
\cf2  * @\ul param\ulnone    pMsg - pointer to the sensor data\cf0 \
\cf2  *\cf0 \
\cf2  * @return  true if message was sent, false if not\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  bool 
\f1\b \cf5 sendSensorMessage
\f0\b0 \cf3 (\cf6 ApiMac_sAddr_t\cf3  *\cf8 pDstAddr\cf3 , \cf6 Smsgs_sensorMsg_t\cf3  *\cf8 pMsg\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     bool \cf5 ret\cf3  = false;\cf0 \
\cf3     uint8_t *\cf5 pMsgBuf\cf3 ;\cf0 \
\cf3     uint16_t \cf5 len\cf3  = SMSGS_BASIC_SENSOR_LEN;\cf0 \
\
\cf3     \cf2 /* Figure out the length */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_tempSensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 len\cf3  += SMSGS_SENSOR_TEMP_LEN;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_lightSensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 len\cf3  += SMSGS_SENSOR_LIGHT_LEN;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_humiditySensor
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 len\cf3  += SMSGS_SENSOR_HUMIDITY_LEN;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 //\ul len\ulnone  += SMSGS_SENSOR_MSG_STATS_LEN;\cf0 \
\cf3         \cf8 len\cf3  += 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_msgStatsField_t\cf3 );\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 len\cf3  += SMSGS_SENSOR_CONFIG_SETTINGS_LEN;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->frameControl & Smsgs_dataFields_hallEffectSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         len += 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_hallEffectSensorField_t);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->frameControl & Smsgs_dataFields_accelSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         len += 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_accelSensorField_t);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg-> frameControl & Smsgs_dataFields_bleSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         len += SMSGS_SENSOR_BLE_LEN;\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->bleSensor.dataLength > MAX_BLE_DATA_LEN)\cf0 \
\cf3         \{\cf0 \
\cf3             pMsg->bleSensor.dataLength = MAX_BLE_DATA_LEN;\cf0 \
\cf3         \}\cf0 \
\cf3         len += pMsg->bleSensor.dataLength;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf8 pMsgBuf\cf3  = (uint8_t *)
\f1\b \cf1 Ssf_malloc
\f0\b0 \cf3 (\cf8 len\cf3 );\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsgBuf\cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         uint8_t *\cf5 pBuf\cf3  = \cf8 pMsgBuf\cf3 ;\cf0 \
\
\cf3         *\cf8 pBuf\cf3 ++ = (uint8_t)
\f2\i \cf9 Smsgs_cmdIds_sensorData
\f0\i0 \cf3 ;\cf0 \
\
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 extAddress\cf3 , SMGS_SENSOR_EXTADDR_LEN);\cf0 \
\cf3         \cf8 pBuf\cf3  += SMGS_SENSOR_EXTADDR_LEN;\cf0 \
\
\cf3         \cf8 pBuf\cf3   = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf8 pMsg\cf3 ->\cf5 frameControl\cf3 );\cf0 \
\
\cf3         \cf2 /* Buffer data in order of frameControl mask, starting with LSB */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_tempSensor
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 tempSensor\cf3 .\cf5 ambienceTemp\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 tempSensor\cf3 .\cf5 objectTemp\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_lightSensor
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 lightSensor\cf3 .\cf5 rawData\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_humiditySensor
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 humiditySensor\cf3 .\cf5 temp\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 humiditySensor\cf3 .\cf5 humidity\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 joinAttempts\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 joinFails\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 msgsAttempted\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 msgsSent\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 trackingRequests\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 trackingResponseAttempts\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 trackingResponseSent\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 configRequests\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 configResponseAttempts\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 configResponseSent\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 channelAccessFailures\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 macAckFailures\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 otherDataRequestFailures\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 syncLossIndications\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 rxDecryptFailures\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,  \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 txEncryptFailures\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , Ssf_resetCount);\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,  Ssf_resetReseason);\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 joinTime\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 interimDelay\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 numBroadcastMsgRcvd\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,  \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 numBroadcastMsglost\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,  \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 avgE2EDelay\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,  \cf8 pMsg\cf3 ->\cf5 msgStats\cf3 .\cf5 worstCaseE2EDelay\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pMsg\cf3 ->\cf5 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 configSettings\cf3 .\cf5 reportingInterval\cf3 );\cf0 \
\cf3             \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 ,\cf0 \
\cf3                                      \cf8 pMsg\cf3 ->\cf5 configSettings\cf3 .\cf5 pollingInterval\cf3 );\cf0 \
\
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->frameControl & Smsgs_dataFields_hallEffectSensor)\cf0 \
\cf3         \{\cf0 \
\cf3             *pBuf++ = (uint8_t)pMsg->hallEffectSensor.fluxLevel;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->frameControl & Smsgs_dataFields_accelSensor)\cf0 \
\cf3         \{\cf0 \
\cf3             pBuf = Util_bufferUint16(pBuf,\cf0 \
\cf3                                      pMsg->accelerometerSensor.xAxis);\cf0 \
\cf3             pBuf = Util_bufferUint16(pBuf,\cf0 \
\cf3                                      pMsg->accelerometerSensor.yAxis);\cf0 \
\cf3             pBuf = Util_bufferUint16(pBuf,\cf0 \
\cf3                                      pMsg->accelerometerSensor.zAxis);\cf0 \
\cf3             *pBuf++ = pMsg->accelerometerSensor.xTiltDet;\cf0 \
\cf3             *pBuf++ = pMsg->accelerometerSensor.yTiltDet;\cf0 \
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (pMsg->frameControl & Smsgs_dataFields_bleSensor)\cf0 \
\cf3         \{\cf0 \
\cf3             uint8_t i;\cf0 \
\cf3             
\f1\b \cf1 for
\f0\b0 \cf3 (i= \cf7 0\cf3 ; i < B_ADDR_LEN; i++)\cf0 \
\cf3             \{\cf0 \
\cf3                 *pBuf++ = pMsg->bleSensor.bleAddr[i];\cf0 \
\cf3             \}\cf0 \
\cf3             pBuf = Util_bufferUint16(pBuf,\cf0 \
\cf3                                      pMsg->bleSensor.manFacID);\cf0 \
\cf3             pBuf = Util_bufferUint16(pBuf,\cf0 \
\cf3                                      pMsg->bleSensor.uuid);\cf0 \
\cf3             *pBuf++ = pMsg->bleSensor.dataLength;\cf0 \
\
\cf3             i = pMsg->bleSensor.dataLength;\cf0 \
\cf3             
\f1\b \cf1 while
\f0\b0 \cf3 (i != \cf7 0\cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 i--;\cf0 \
\cf3                 *pBuf++ = pMsg->bleSensor.data[i];\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3         \cf8 ret\cf3  = 
\f1\b \cf1 Sensor_sendMsg
\f0\b0 \cf3 (
\f2\i \cf9 Smsgs_cmdIds_sensorData
\f0\i0 \cf3 , \cf8 pDstAddr\cf3 , true, \cf8 len\cf3 , \cf8 pMsgBuf\cf3 );\cf0 \
\
\cf3         
\f1\b \cf1 Ssf_free
\f0\b0 \cf3 (\cf8 pMsgBuf\cf3 );\cf0 \
\cf3     \}\cf0 \
\
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  (\cf8 ret\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !defined(OAD_IMG_A) && !defined(POWER_MEAS) */\cf0 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Process the \ul Config\ulnone  Request message.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       pDataInd - pointer to the data indication information\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processConfigRequest
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf6 Smsgs_statusValues_t\cf3  \cf5 stat\cf3  = 
\f2\i \cf9 Smsgs_statusValues_invalid
\f0\i0 \cf3 ;\cf0 \
\cf3     \cf6 Smsgs_configRspMsg_t\cf3  \cf5 configRsp\cf3 ;\cf0 \
\
\cf3     
\f1\b \cf1 memset
\f0\b0 \cf3 (&\cf8 configRsp\cf3 , \cf7 0\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_configRspMsg_t\cf3 ));\cf0 \
\
\cf3     \cf2 /* Make sure the message is the correct size */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 len\cf3  == SMSGS_CONFIG_REQUEST_MSG_LENGTH)\cf0 \
\cf3     \{\cf0 \
\cf3         uint8_t *\cf5 pBuf\cf3  = \cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 p\cf3 ;\cf0 \
\cf3         uint16_t \cf5 frameControl\cf3 ;\cf0 \
\cf3         uint32_t \cf5 reportingInterval\cf3 ;\cf0 \
\cf3         uint32_t \cf5 pollingInterval\cf3 ;\cf0 \
\
\cf3         \cf2 /* Parse the message */\cf0 \
\cf3         configSettings.\cf5 cmdId\cf3  = (\cf6 Smsgs_cmdIds_t\cf3 )*\cf8 pBuf\cf3 ++;\cf0 \
\cf3         \cf8 frameControl\cf3  = 
\f1\b \cf1 Util_parseUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 );\cf0 \
\cf3         \cf8 pBuf\cf3  += \cf7 2\cf3 ;\cf0 \
\cf3         \cf8 reportingInterval\cf3  = 
\f1\b \cf1 Util_parseUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 );\cf0 \
\cf3         \cf8 pBuf\cf3  += \cf7 4\cf3 ;\cf0 \
\cf3         \cf8 pollingInterval\cf3  = 
\f1\b \cf1 Util_parseUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 );\cf0 \
\
\cf3         \cf8 stat\cf3  = 
\f2\i \cf9 Smsgs_statusValues_success
\f0\i0 \cf3 ;\cf0 \
\cf3         collectorAddr.\cf5 addrMode\cf3  = \cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 .\cf5 addrMode\cf3 ;\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (collectorAddr.\cf5 addrMode\cf3  == 
\f2\i \cf9 ApiMac_addrType_short
\f0\i0 \cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             collectorAddr.\cf5 addr\cf3 .\cf5 shortAddr\cf3  = \cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 .\cf5 addr\cf3 .\cf5 shortAddr\cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 memcpy
\f0\b0 \cf3 (collectorAddr.\cf5 addr\cf3 .\cf5 extAddr\cf3 , \cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 .\cf5 addr\cf3 .\cf5 extAddr\cf3 ,\cf0 \
\cf3                    (APIMAC_SADDR_EXT_LEN));\cf0 \
\cf3         \}\cf0 \
\
\cf3         configSettings.\cf5 frameControl\cf3  = 
\f1\b \cf1 validateFrameControl
\f0\b0 \cf3 (\cf8 frameControl\cf3 );\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (configSettings.\cf5 frameControl\cf3  != \cf8 frameControl\cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 stat\cf3  = 
\f2\i \cf9 Smsgs_statusValues_partialSuccess
\f0\i0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         \cf8 configRsp\cf3 .\cf5 frameControl\cf3  = configSettings.\cf5 frameControl\cf3 ;\cf0 \
\
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 reportingInterval\cf3  < MIN_REPORTING_INTERVAL)\cf0 \
\cf3            || (\cf8 reportingInterval\cf3  > MAX_REPORTING_INTERVAL))\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 stat\cf3  = 
\f2\i \cf9 Smsgs_statusValues_partialSuccess
\f0\i0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  POWER_MEAS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             configSettings.\cf5 reportingInterval\cf3  = \cf8 reportingInterval\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             \{\cf0 \
\cf3                 uint32_t \cf5 randomNum\cf3 ;\cf0 \
\cf3                 \cf8 randomNum\cf3  = ((
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 16\cf3 ) +\cf0 \
\cf3                              (
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 8\cf3 ) + 
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 ());\cf0 \
\cf3                 \cf8 randomNum\cf3  = (\cf8 randomNum\cf3  % \cf8 reportingInterval\cf3 ) +\cf0 \
\cf3                         SENSOR_MIN_POLL_TIME;\cf0 \
\cf3                 
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (\cf8 randomNum\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                 Lpstk_setSensorReadTimer((Lpstk_SensorMask)(LPSTK_HUMIDITY|\cf0 \
\cf3                                                              LPSTK_TEMPERATURE|\cf0 \
\cf3                                                              LPSTK_LIGHT|\cf0 \
\cf3                                                              LPSTK_HALL_EFFECT|\cf0 \
\cf3                                                              LPSTK_ACCELEROMETER),\cf0 \
\cf3                                                              reportingInterval);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             \}\cf0 \
\
\cf3         \}\cf0 \
\cf3         \cf8 configRsp\cf3 .\cf5 reportingInterval\cf3  = configSettings.\cf5 reportingInterval\cf3 ;\cf0 \
\
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 pollingInterval\cf3  < MIN_POLLING_INTERVAL)\cf0 \
\cf3            || (\cf8 pollingInterval\cf3  > MAX_POLLING_INTERVAL))\cf0 \
\cf3         \{\cf0 \
\cf3             \cf8 stat\cf3  = 
\f2\i \cf9 Smsgs_statusValues_partialSuccess
\f0\i0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3         \{\cf0 \
\cf3             configSettings.\cf5 pollingInterval\cf3  = \cf8 pollingInterval\cf3 ;\cf0 \
\cf3             
\f1\b \cf1 Jdllc_setPollRate
\f0\b0 \cf3 (configSettings.\cf5 pollingInterval\cf3 );\cf0 \
\cf3         \}\cf0 \
\cf3         \cf8 configRsp\cf3 .\cf5 pollingInterval\cf3  = configSettings.\cf5 pollingInterval\cf3 ;\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Send the response message */\cf0 \
\cf3     \cf8 configRsp\cf3 .\cf5 cmdId\cf3  = 
\f2\i \cf9 Smsgs_cmdIds_configRsp
\f0\i0 \cf3 ;\cf0 \
\cf3     \cf8 configRsp\cf3 .\cf5 status\cf3  = \cf8 stat\cf3 ;\cf0 \
\
\cf3     \cf2 /* Update the user */\cf0 \
\cf3     
\f1\b \cf1 Ssf_configurationUpdate
\f0\b0 \cf3 (&\cf8 configRsp\cf3 );\cf0 \
\
\cf3     \cf2 /* Response the the source device */\cf0 \
\cf3     
\f1\b \cf1 sendConfigRsp
\f0\b0 \cf3 (&\cf8 pDataInd\cf3 ->\cf5 srcAddr\cf3 , &\cf8 configRsp\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Sync BLE application with new data */\cf0 \
\cf3     RemoteDisplay_updateSensorData();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM && !DMM_CENTRAL */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Process the Broadcast Control \ul Msg\ulnone .\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone       pDataInd - pointer to the data indication information\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 processBroadcastCtrlMsg
\f0\b0 \cf3 (\cf6 ApiMac_mcpsDataInd_t\cf3  *\cf8 pDataInd\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf6 Smsgs_broadcastcmdmsg_t\cf3  \cf5 broadcastCmd\cf3 ;\cf0 \
\
\cf3     
\f1\b \cf1 memset
\f0\b0 \cf3 (&\cf8 broadcastCmd\cf3 , \cf7 0\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Smsgs_broadcastcmdmsg_t\cf3 ));\cf0 \
\
\cf3     \cf2 /* Make sure the message is the correct size */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 len\cf3  == SMSGS_BROADCAST_CMD_LENGTH)\cf0 \
\cf3     \{\cf0 \
\cf3         uint8_t *\cf5 pBuf\cf3  = \cf8 pDataInd\cf3 ->\cf5 msdu\cf3 .\cf5 p\cf3 ;\cf0 \
\cf3         uint16_t \cf5 broadcastMsgId\cf3 ;\cf0 \
\
\cf3         \cf2 /* Parse the message */\cf0 \
\cf3         uint8_t \cf5 cmdId\cf3  = (\cf6 Smsgs_cmdIds_t\cf3 )*\cf8 pBuf\cf3 ++;\cf0 \
\cf3         \cf8 broadcastMsgId\cf3  = 
\f1\b \cf1 Util_parseUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 );\cf0 \
\
\cf3         \cf2 /* Process Broadcast Command Message */\cf0 \
\cf3         Sensor_msgStats.\cf5 numBroadcastMsgRcvd\cf3 ++;\cf0 \
\
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (!initBroadcastMsg)\cf0 \
\cf3         \{\cf0 \
\cf3             \cf2 /* Not the first broadcast \ul msg\ulnone  \ul rcvdd\ulnone  after join or a rejoin*/\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 broadcastMsgId\cf3  - lastRcvdBroadcastMsgId) > \cf7 1\cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 Sensor_msgStats.\cf5 numBroadcastMsglost\cf3  +=\cf0 \
\cf3                                 ((\cf8 broadcastMsgId\cf3  - lastRcvdBroadcastMsgId) \cf7 -1\cf3 );\cf0 \
\cf3             \}\cf0 \
\cf3         \}\cf0 \
\
\cf3         lastRcvdBroadcastMsgId = \cf8 broadcastMsgId\cf3 ;\cf0 \
\cf3         \cf2 /*To handle the very first broadcast \ul msg\ulnone  \ul rcvdd\ulnone  after join or a rejoin*/\cf0 \
\cf3         initBroadcastMsg = false;\cf0 \
\
\cf3         \cf2 /* Switch On or Off LED based on broadcast \ul Msg\ulnone  Id */\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 ((\cf8 broadcastMsgId\cf3  % \cf7 2\cf3 ) == \cf7 0\cf3 )\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 Ssf_OnLED
\f0\b0 \cf3 ();\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 Ssf_OffLED
\f0\b0 \cf3 ();\cf0 \
\cf3         \}\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Build and send \ul Config\ulnone  Response message\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pDstAddr - Where to send the message\cf0 \
\cf2  * @\ul param\ulnone    pMsg - pointer to the \ul Config\ulnone  Response\cf0 \
\cf2  *\cf0 \
\cf2  * @return  true if message was sent, false if not\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  bool 
\f1\b \cf5 sendConfigRsp
\f0\b0 \cf3 (\cf6 ApiMac_sAddr_t\cf3  *\cf8 pDstAddr\cf3 , \cf6 Smsgs_configRspMsg_t\cf3  *\cf8 pMsg\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t \cf5 msgBuf\cf3 [SMSGS_CONFIG_RESPONSE_MSG_LENGTH];\cf0 \
\cf3     uint8_t *\cf5 pBuf\cf3  = \cf8 msgBuf\cf3 ;\cf0 \
\
\cf3     *\cf8 pBuf\cf3 ++ = (uint8_t) 
\f2\i \cf9 Smsgs_cmdIds_configRsp
\f0\i0 \cf3 ;\cf0 \
\cf3     \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 status\cf3 );\cf0 \
\cf3     \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint16
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 frameControl\cf3 );\cf0 \
\cf3     \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 reportingInterval\cf3 );\cf0 \
\cf3     \cf8 pBuf\cf3  = 
\f1\b \cf1 Util_bufferUint32
\f0\b0 \cf3 (\cf8 pBuf\cf3 , \cf8 pMsg\cf3 ->\cf5 pollingInterval\cf3 );\cf0 \
\
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  (
\f1\b \cf1 Sensor_sendMsg
\f0\b0 \cf3 (
\f2\i \cf9 Smsgs_cmdIds_configRsp
\f0\i0 \cf3 , \cf8 pDstAddr\cf3 , true,\cf0 \
\cf3                     SMSGS_CONFIG_RESPONSE_MSG_LENGTH, \cf8 msgBuf\cf3 ));\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Filter the frameControl with readings supported by this device.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    frameControl - suggested frameControl\cf0 \
\cf2  *\cf0 \
\cf2  * @return  new frame control settings supported\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  uint16_t 
\f1\b \cf5 validateFrameControl
\f0\b0 \cf3 (uint16_t \cf8 frameControl\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint16_t \cf5 newFrameControl\cf3  = \cf7 0\cf3 ;\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(TEMP_SENSOR)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_tempSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_tempSensor;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  defined(LIGHT_SENSOR) || defined(LPSTK)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_lightSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_lightSensor;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \

\f1\b \cf1 #if
\f0\b0 \cf3  defined(HUMIDITY_SENSOR) || defined(LPSTK)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_humiditySensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_humiditySensor;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_hallEffectSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_hallEffectSensor;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_accelSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_accelSensor;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 newFrameControl\cf3  |= 
\f2\i \cf9 Smsgs_dataFields_msgStats
\f0\i0 \cf3 ;\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (\cf8 frameControl\cf3  & 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 )\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 newFrameControl\cf3  |= 
\f2\i \cf9 Smsgs_dataFields_configSettings
\f0\i0 \cf3 ;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (frameControl & Smsgs_dataFields_bleSensor)\cf0 \
\cf3     \{\cf0 \
\cf3         newFrameControl |= Smsgs_dataFields_bleSensor;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 return
\f0\b0 \cf3  (\cf8 newFrameControl\cf3 );\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(DEVICE_TYPE_MSG)\cf0 \

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  Sensor_sendDeviceTypeResponse(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t cmdBytes[SMSGS_DEVICE_TYPE_RESPONSE_MSG_LEN];\cf0 \
\
\cf3     \cf2 /* send the response message directly */\cf0 \
\cf3     cmdBytes[\cf7 0\cf3 ] = (uint8_t) Smsgs_cmdIds_DeviceTypeRsp;\cf0 \
\cf3     cmdBytes[\cf7 1\cf3 ] = DeviceFamily_ID;\cf0 \
\cf3     cmdBytes[\cf7 2\cf3 ] = DeviceType_ID;\cf0 \
\
\cf3     Sensor_sendMsg(Smsgs_cmdIds_DeviceTypeRsp,\cf0 \
\cf3             &collectorAddr, true,\cf0 \
\cf3             SMSGS_DEVICE_TYPE_RESPONSE_MSG_LEN, cmdBytes);\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* DEVICE_TYPE_MSG */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   The device joined callback.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pDevInfo - This device's information\cf0 \
\cf2  * @\ul param\ulnone    pParentInfo - This is the parent's information\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcJoinedCb
\f0\b0 \cf3 (\cf6 ApiMac_deviceDescriptor_t\cf3  *\cf8 pDevInfo\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                           \cf6 Llc_netInfo_t\cf3  *\cf8 pParentInfo\cf3 )\cf0 \
\cf3 \{\cf0 \
\cf3     uint32_t \cf5 randomNum\cf3  = \cf7 0\cf3 ;\cf0 \
\
\cf3     \cf2 /* Copy the parent information */\cf0 \
\cf3     
\f1\b \cf1 memcpy
\f0\b0 \cf3 (&parentInfo, \cf8 pParentInfo\cf3 , 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (\cf6 Llc_netInfo_t\cf3 ));\cf0 \
\
\cf3     \cf2 /* Set the collector's address as the parent's address */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  (\cf8 pParentInfo\cf3 ->\cf5 fh\cf3  && CONFIG_RX_ON_IDLE)\cf0 \
\cf3     \{\cf0 \
\cf3         collectorAddr.\cf5 addrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_extended
\f0\i0 \cf3 ;\cf0 \
\cf3         
\f1\b \cf1 memcpy
\f0\b0 \cf3 (collectorAddr.\cf5 addr\cf3 .\cf5 extAddr\cf3 , \cf8 pParentInfo\cf3 ->\cf5 devInfo\cf3 .\cf5 extAddress\cf3 ,\cf0 \
\cf3                (APIMAC_SADDR_EXT_LEN));\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         collectorAddr.\cf5 addrMode\cf3  = 
\f2\i \cf9 ApiMac_addrType_short
\f0\i0 \cf3 ;\cf0 \
\cf3         collectorAddr.\cf5 addr\cf3 .\cf5 shortAddr\cf3  = \cf8 pParentInfo\cf3 ->\cf5 devInfo\cf3 .\cf5 shortAddress\cf3 ;\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Start the reporting timer */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (CONFIG_FH_ENABLE)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf8 randomNum\cf3  = ((
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 16\cf3 ) +\cf0 \
\cf3                      (
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 8\cf3 ) + 
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 ());\cf0 \
\cf3         \cf8 randomNum\cf3  = (\cf8 randomNum\cf3  % configSettings.\cf5 reportingInterval\cf3 ) +\cf0 \
\cf3                     SENSOR_MIN_POLL_TIME;\cf0 \
\cf3         
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (\cf8 randomNum\cf3 );\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3        uint32_t \cf5 randomNum\cf3 ;\cf0 \
\cf3        \cf8 randomNum\cf3  = ((
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 16\cf3 ) +\cf0 \
\cf3                     (
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 () << \cf7 8\cf3 ) + 
\f1\b \cf1 ApiMac_randomByte
\f0\b0 \cf3 ());\cf0 \
\cf3        \cf8 randomNum\cf3  = (\cf8 randomNum\cf3  % configSettings.\cf5 reportingInterval\cf3  ) +\cf0 \
\cf3                    SENSOR_MIN_POLL_TIME;\cf0 \
\cf3        
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (\cf8 randomNum\cf3 );\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Inform the user of the joined information */\cf0 \
\cf3     
\f1\b \cf1 Ssf_networkUpdate
\f0\b0 \cf3 (rejoining, \cf8 pDevInfo\cf3 , \cf8 pParentInfo\cf3 );\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         SM_Sensor_SAddress = pDevInfo->shortAddress;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 ((rejoining == false) && (\cf8 pParentInfo\cf3 ->\cf5 fh\cf3  == false))\cf0 \
\cf3     \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         ApiMac_status_t stat;\cf0 \
\cf3         \cf2 /* Add the parent to the security device list */\cf0 \
\cf3         stat = Jdllc_addSecDevice(pParentInfo->devInfo.panID,\cf0 \
\cf3                                   pParentInfo->devInfo.shortAddress,\cf0 \
\cf3                                   &pParentInfo->devInfo.extAddress, \cf7 0\cf3 );\cf0 \
\cf3         
\f1\b \cf1 if
\f0\b0 \cf3 (stat != ApiMac_status_success)\cf0 \
\cf3         \{\cf0 \
\cf3             Ssf_displayError(\cf4 "\ul Auth\ulnone  Error: 0x"\cf3 , (uint8_t)stat);\cf0 \
\cf3         \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_MAC_SECURITY */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  (CONFIG_MAC_SUPERFRAME_ORDER != 15) && defined(MAC_NO_AUTO_REQ)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /*\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      * Set MAC Auto Request to false to enable multiple poll requests\cf0 \
\cf2      * per beacon interval\cf0 \
\cf2      */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_autoRequest, false);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OSAL_PORT2TIRTOS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Calculate Join Time */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (ClockP_getSystemTicks() < joinTimeTicks)\cf0 \
\cf3     \{\cf0 \
\cf3         joinTimeTicks = ClockP_getSystemTicks() + (\cf7 0xFFFFFFFF\cf3 -joinTimeTicks);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         joinTimeTicks = ClockP_getSystemTicks() - joinTimeTicks;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* Calculate Join Time */\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () < joinTimeTicks)\cf0 \
\cf3     \{\cf0 \
\cf3         joinTimeTicks = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () + (\cf7 0xFFFFFFFF\cf3 -joinTimeTicks);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{\cf0 \
\cf3         joinTimeTicks = 
\f1\b \cf1 ICall_getTicks
\f0\b0 \cf3 () - joinTimeTicks;\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     Sensor_msgStats.\cf5 joinTime\cf3  = joinTimeTicks / TICKPERIOD_MS_US;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DISPLAY_PER_STATS\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* clear the \ul stats\ulnone  used for PER so that we start out at a\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2      * zeroed state\cf0 \
\cf2      */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     Sensor_msgStats.macAckFailures = \cf7 0\cf3 ;\cf0 \
\cf3     Sensor_msgStats.otherDataRequestFailures = \cf7 0\cf3 ;\cf0 \
\cf3     Sensor_msgStats.msgsSent = \cf7 0\cf3 ;\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   \ul Disassociation\ulnone  indication callback.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pExtAddress - extended address\cf0 \
\cf2  * @\ul param\ulnone    reason - reason for \ul disassociation\cf0 \ulnone \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcDisassocIndCb
\f0\b0 \cf3 (\cf6 ApiMac_sAddrExt_t\cf3  *\cf8 pExtAddress\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                                \cf6 ApiMac_disassocateReason_t\cf3  \cf8 reason\cf3 )\cf0 \
\cf3 \{\cf0 \
\cf3     \cf2 /* Stop the reporting timer */\cf0 \
\cf3     
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (\cf7 0\cf3 );\cf0 \
\cf3     
\f1\b \cf1 Ssf_clearNetworkInfo
\f0\b0 \cf3 ();\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_secDeleteDevice(pExtAddress);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     SM_removeEntryFromSeedKeyTable(&ApiMac_extAddr);\cf0 \
\cf3     Ssf_clearDeviceKeyInfo();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_IDLE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* OAD abort with no auto resume */\cf0 \
\cf3     OADClient_abort(false);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 //FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   \ul Disassociation\ulnone  confirm callback to an application \ul intiated\cf0 \ulnone \
\cf2  *          \ul disassociation\ulnone  request.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pExtAddress - extended address\cf0 \
\cf2  * @\ul param\ulnone    status - status of \ul disassociation\cf0 \ulnone \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcDisassocCnfCb
\f0\b0 \cf3 (\cf6 ApiMac_sAddrExt_t\cf3  *\cf8 pExtAddress\cf3 ,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                                \cf6 ApiMac_status_t\cf3  \cf8 status\cf3 )\cf0 \
\cf3 \{\cf0 \
\cf3     \cf2 /* Stop the reporting timer */\cf0 \
\cf3     
\f1\b \cf1 Ssf_setReadingClock
\f0\b0 \cf3 (\cf7 0\cf3 );\cf0 \
\cf3     
\f1\b \cf1 Ssf_clearNetworkInfo
\f0\b0 \cf3 ();\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     ApiMac_secDeleteDevice(pExtAddress);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     SM_removeEntryFromSeedKeyTable(&ApiMac_extAddr);\cf0 \
\cf3     Ssf_clearDeviceKeyInfo();\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_IDLE);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \cf2 /* OAD abort with no auto resume */\cf0 \
\cf3     OADClient_abort(false);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 //FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   JDLLC state change callback.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    state - new state\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  
\f1\b \cf5 jdllcStateChangeCb
\f0\b0 \cf3 (\cf6 Jdllc_states_t\cf3  \cf8 state\cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_NATIVE_OAD\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 ( (state == Jdllc_states_joined) || (state == Jdllc_states_rejoined))\cf0 \
\cf3     \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  (CONFIG_MAC_SUPERFRAME_ORDER == 15)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* resume an OAD that may have aborted */\cf0 \
\cf3         OADClient_resume(\cf7 30000\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #else
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3         \cf2 /* resume an OAD that may have aborted */\cf0 \
\cf3         OADClient_resume(\cf7 60000\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (state == Jdllc_states_orphan)\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 /* OAD abort with no auto resume */\cf0 \
\cf3         OADClient_abort(false);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_NATIVE_OAD */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 (state == Jdllc_states_initRestoring)\cf0 \
\cf3     \{\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 ( (state == Jdllc_states_joined) || (state == Jdllc_states_rejoined))\cf0 \
\cf3     \{\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_CONNECTED);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 (state == Jdllc_states_orphan)\cf0 \
\cf3     \{\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf3  
\f1\b \cf1 if
\f0\b0 \cf3 ( (state == Jdllc_states_initWaiting) || (state == Jdllc_states_accessDenied) )\cf0 \
\cf3     \{\cf0 \
\cf3         DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_UNINIT);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_updateSensorJoinState(state);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* BLE_START && USE_DMM && !DMM_CENTRAL */\cf0 \
\

\f1\b \cf1 #ifndef
\f0\b0 \cf3  CUI_DISABLE\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 Ssf_stateChangeUpdate
\f0\b0 \cf3 (\cf8 state\cf3 );\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* CUI_DISABLE */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  OAD_IMG_A\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3 ( (state == Jdllc_states_joined) || (state == Jdllc_states_rejoined))\cf0 \
\cf3     \{\cf0 \
\cf3         Util_setEvent(&Sensor_events, SENSOR_OAD_SEND_RESET_RSP_EVT);\cf0 \
\cf3     \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* OAD_IMG_A */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Sync Loss callback indication beacon sync has been lost.\cf0 \
\cf2  *\cf0 \
\cf2  * @\ul param\ulnone    pSyncLossInd - Sync Loss Indication\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  macSyncLossCb(ApiMac_mlmeSyncLossInd_t *pSyncLossInd)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf2 /* Update policy */\cf0 \
\cf3     DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_PROVISIONING);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(BLE_START) && (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     RemoteDisplay_updateSensorJoinState((Jdllc_states_t)RemoteDisplay_JOIN_STATE_SYNC_LOSS);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      DMM Provisioning connect (Association) callback function\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  provisionConnectCb(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     Ssf_setProvisioningClock(true);\cf0 \
\
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      DMM Provisioning disconnect (\ul Disassocation\ulnone ) callback function\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  provisionDisconnectCb(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     Ssf_setProvisioningClock(false);\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* !DMM_CENTRAL */\cf0 \

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_SECURE_COMMISSIONING\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Security manager failure processing function\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  smFailCMProcessCb(ApiMac_deviceDescriptor_t *devInfo, bool rxOnIdle,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3                        bool keyRefreshment, SMMsgs_errorCode_t errorCode)\cf0 \
\cf3 \{\cf0 \
\cf3     \cf2 /* restore, write back current \ul Pib\ulnone  value for auto request attribute */\cf0 \
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_autoRequest, currAutoReq);\cf0 \
\
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  (SM_forceStopped == true)\cf0 \
\cf3     \{\cf0 \
\cf3         Util_setEvent(&Sensor_events, SENSOR_DISASSOC_EVT);\cf0 \
\cf3     \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_UNINIT);\cf0 \
\cf3     RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_FAIL);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM */\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief      Security manager success processing function\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  smSuccessCMProcessCb(ApiMac_deviceDescriptor_t *devInfo, bool keyRefreshment)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf2 /* restore, write back current \ul Pib\ulnone  value for auto request attribute */\cf0 \
\cf3     ApiMac_mlmeSetReqBool(ApiMac_attribute_autoRequest, currAutoReq);\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  USE_DMM\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     DMMPolicy_updateApplicationState(DMMPolicy_StackRole_154Sensor, DMMPOLICY_154_CONNECTED);\cf0 \
\cf3     RemoteDisplay_updateSmState(SMCOMMISSIONSTATE_SUCCESS);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* FEATURE_SECURE_COMMISSIONING */\cf0 \
\

\f1\b \cf1 #if
\f0\b0 \cf3  (USE_DMM) && !(DMM_CENTRAL)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /** @brief  Set remote display callback functions\cf0 \
\cf2  *\cf0 \
\cf2  *  @\ul param\ulnone   remoteDisplayAttr  Remote display attribute value to set\cf0 \
\cf2  *  @\ul param\ulnone   value  pointer to data from remote \ul dispaly\ulnone  application\cf0 \
\cf2  *  @\ul param\ulnone   \ul len\ulnone   length of data from remote display application\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  setRDAttrCb(RemoteDisplayAttr_t remoteDisplayAttr,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 void
\f0\b0 \cf3  *
\f1\b \cf1 const
\f0\b0 \cf3  value, uint8_t len)\cf0 \
\cf3 \{\cf0 \
\cf3     
\f1\b \cf1 switch
\f0\b0 \cf3 (remoteDisplayAttr)\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  RemoteDisplayAttr_ReportInterval:\cf0 \
\cf3         \{\cf0 \
\cf3             uint8_t *byteArr = (uint8_t*)value;\cf0 \
\cf3             uint32_t reportingInterval;\cf0 \
\cf3             uint32_t randomNum;\cf0 \
\
\cf3             reportingInterval = Util_buildUint32(byteArr[\cf7 3\cf3 ], byteArr[\cf7 2\cf3 ], byteArr[\cf7 1\cf3 ], byteArr[\cf7 0\cf3 ]);\cf0 \
\cf3             configSettings.reportingInterval = reportingInterval;\cf0 \
\
\cf3             randomNum = ((ApiMac_randomByte() << \cf7 16\cf3 ) +\cf0 \
\cf3                          (ApiMac_randomByte() << \cf7 8\cf3 ) + ApiMac_randomByte());\cf0 \
\cf3             randomNum = (randomNum % reportingInterval) +\cf0 \
\cf3                     SENSOR_MIN_POLL_TIME;\cf0 \
\
\cf3             Ssf_setReadingClock(randomNum);\cf0 \
\
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  RemoteDisplayAttr_CollLed:\cf0 \
\cf3         \{\cf0 \
\cf3             uint8_t cmdBytes[SMSGS_INDENTIFY_LED_REQUEST_MSG_LEN];\cf0 \
\
\cf3             \cf2 /* send the response message directly */\cf0 \
\cf3             cmdBytes[\cf7 0\cf3 ] = (uint8_t) Smsgs_cmdIds_IdentifyLedReq;\cf0 \
\cf3             cmdBytes[\cf7 1\cf3 ] = *((uint8_t*)value);\cf0 \
\cf3             Sensor_sendMsg(Smsgs_cmdIds_IdentifyLedReq,\cf0 \
\cf3                     &collectorAddr, true,\cf0 \
\cf3                     SMSGS_INDENTIFY_LED_REQUEST_MSG_LEN,\cf0 \
\cf3                     cmdBytes);\cf0 \
\
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 default
\f0\b0 \cf3 :\cf0 \
\cf3             
\f1\b \cf1 return
\f0\b0 \cf3 ;\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /** @brief  Get remote display callback functions\cf0 \
\cf2  *\cf0 \
\cf2  *  @\ul param\ulnone   remoteDisplayAttr  Remote display attribute value to set\cf0 \
\cf2  *\cf0 \
\cf2  *  @return  void *  Current value of data present in 15.4 application\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  getRDAttrCb(RemoteDisplayAttr_t remoteDisplayAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *value, uint8_t len)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     
\f1\b \cf1 switch
\f0\b0 \cf3 (remoteDisplayAttr)\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  RemoteDisplayAttr_ReportInterval:\cf0 \
\cf3         \{\cf0 \
\cf3             Util_bufferUint32(value, configSettings.reportingInterval);\cf0 \
\cf3             \cf2 // Fix byte order\cf0 \
\cf3             swapBytes((uint8_t *)value, len);\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  RemoteDisplayAttr_CollLed:\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  RemoteDisplayAttr_SensorData:\cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  defined(TEMP_SENSOR) && !defined(POWER_MEAS)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             memcpy(value, &tempSensor.ambienceTemp, len);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 default
\f0\b0 \cf3 :\cf0 \
\cf3             \cf2 // Attribute not found\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3 \}\cf0 \
\
\
\
\pard\pardeftab720\partightenfactor0
\cf2 /** @brief  Set provisioning callback functions\cf0 \
\cf2  *\cf0 \
\cf2  *  @\ul param\ulnone   ProvisionAttr_t  Remote display attribute value to set\cf0 \
\cf2  *  @\ul param\ulnone   value  pointer to data from remote \ul dispaly\ulnone  application\cf0 \
\cf2  *  @\ul param\ulnone   \ul len\ulnone   length of data from remote display application\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  setProvisioningCb(ProvisionAttr_t provisioningAttr,\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3     
\f1\b \cf1 void
\f0\b0 \cf3  *
\f1\b \cf1 const
\f0\b0 \cf3  value, uint8_t len)\cf0 \
\cf3 \{\cf0 \
\cf3     uint8_t *byteArr = (uint8_t *)value;\cf0 \
\
\cf3     
\f1\b \cf1 switch
\f0\b0 \cf3 (provisioningAttr)\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_PanId:\cf0 \
\cf3         \{\cf0 \
\cf3             uint16_t newPanId;\cf0 \
\
\cf3             newPanId = Util_buildUint16(byteArr[\cf7 1\cf3 ], byteArr[\cf7 0\cf3 ]);\cf0 \
\cf3             Jdllc_setJoiningPanId(newPanId);\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_SensorChannelMask:\cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifndef
\f0\b0 \cf3  CUI_DISABLE\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             \cf2 // Validate and correct the channel mask received over BLE\cf0 \
\cf3             
\f1\b \cf1 for
\f0\b0 \cf3  (uint8_t i = \cf7 0\cf3 ; i < APIMAC_154G_CHANNEL_BITMAP_SIZ; i++)\cf0 \
\cf3             \{\cf0 \
\cf3                 Ssf_validateChMask(byteArr, i);\cf0 \
\cf3             \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* CUI_DISABLE */\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf3             Jdllc_setChanMask(byteArr);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #if
\f0\b0 \cf3  CONFIG_FH_ENABLE\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             Jdllc_setAsyncChanMask(byteArr);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_NtwkKey:\cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             Jdllc_setDefaultKey(byteArr);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 default
\f0\b0 \cf3 :\cf0 \
\cf3             
\f1\b \cf1 return
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /** @brief  Get provisioning callback functions\cf0 \
\cf2  *\cf0 \
\cf2  *  @\ul param\ulnone   ProvisionAttr_t  Remote display attribute value to set\cf0 \
\cf2  *\cf0 \
\cf2  *  @return  uint8_t  Current value of data present in 15.4 application\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  getProvisioningCb(ProvisionAttr_t provisioningAttr, 
\f1\b \cf1 void
\f0\b0 \cf3  *value, uint8_t len)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     
\f1\b \cf1 switch
\f0\b0 \cf3 (provisioningAttr)\cf0 \
\cf3     \{\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_PanId:\cf0 \
\cf3         \{\cf0 \
\cf3             
\f1\b \cf1 if
\f0\b0 \cf3 (len == \cf7 2\cf3 )\cf0 \
\cf3             \{\cf0 \
\cf3                 uint16_t panId;\cf0 \
\cf3                 uint8_t tmpByteSwap;\cf0 \
\
\cf3                 Jdllc_getJoiningPanId(&panId);\cf0 \
\
\cf3                 Util_bufferUint16(value, panId);\cf0 \
\
\cf3                 \cf2 // Switch byte order\cf0 \
\cf3                 tmpByteSwap = ((uint8_t*)value)[\cf7 0\cf3 ];\cf0 \
\cf3                 ((uint8_t *)value)[\cf7 0\cf3 ] = ((uint8_t *)value)[\cf7 1\cf3 ];\cf0 \
\cf3                 ((uint8_t *)value)[\cf7 1\cf3 ] = tmpByteSwap;\cf0 \
\cf3             \}\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_Freq:\cf0 \
\cf3         \{\cf0 \
\cf3             *(uint8_t*)value = Jdllc_getFreq();\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_SensorChannelMask:\cf0 \
\cf3         \{\cf0 \
\cf3             Jdllc_getChanMask((uint8_t *)value);\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_FFDAddr:\cf0 \
\cf3         \{\cf0 \
\cf3             Jdllc_getFfdAddr((uint8_t *)value);\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_NtwkKey:\cf0 \
\cf3         \{\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #ifdef
\f0\b0 \cf3  FEATURE_MAC_SECURITY\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             Jdllc_getDefaultKey((uint8_t *)value);\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 case
\f0\b0 \cf3  ProvisionAttr_ProvState:\cf0 \
\cf3         \{\cf0 \
\cf3             *(uint8_t *)value = Jdllc_getProvState();\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3         
\f1\b \cf1 default
\f0\b0 \cf3 :\cf0 \
\cf3             \cf2 // Attribute not found\cf0 \
\cf3             
\f1\b \cf1 break
\f0\b0 \cf3 ;\cf0 \
\cf3         \}\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*!\cf0 \
\cf2  * @brief   Helper function to swap the byte order for an input array\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  swapBytes(uint8_t *arr, uint8_t len)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     uint8_t i,j, tmp;\cf0 \
\
\cf3     
\f1\b \cf1 for
\f0\b0 \cf3  (i = \cf7 0\cf3 , j = len - \cf7 1\cf3 ; i < len/\cf7 2\cf3  ; i++,j--)\cf0 \
\cf3     \{\cf0 \
\cf3         tmp = arr[i];\cf0 \
\cf3         arr[i] = arr[j];\cf0 \
\cf3         arr[j] = tmp;\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* USE_DMM && !DMM_CENTRAL */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_OAD\cf0 \
\
\pard\pardeftab720\partightenfactor0
\cf2 /*********************************************************************\cf0 \
\cf2  * @\ul fn\ulnone       Sensor_dmmPausePolicyCb\cf0 \
\cf2  *\cf0 \
\cf2  * @brief   DMM Policy callback to pause 154 Stack\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  Sensor_dmmPausePolicyCb(uint16_t pause)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  (pause)\cf0 \
\cf3     \{   \cf2 //pause 154sensor\cf0 \
\cf3         Util_setEvent(&Sensor_events, SENSOR_PAUSE_EVT);\cf0 \
\cf3     \}\cf0 \
\cf3     
\f1\b \cf1 else
\f0\b0 \cf0 \
\cf3     \{   \cf2 //\ul unpause\ulnone  154sensor\cf0 \
\cf3         Util_setEvent(&Sensor_events, SENSOR_RESUME_EVT);\cf0 \
\cf3     \}\cf0 \
\
\cf3     \cf2 /* Wake up the application thread when it waits for clock event */\cf0 \
\cf3     Ssf_PostAppSem();\cf0 \
\cf3 \}\cf0 \
\
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  LPSTK\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*********************************************************************\cf0 \
\cf2  * @\ul fn\ulnone       lpstkAccelerometerTiltCb\cf0 \
\cf2  *\cf0 \
\cf2  * @brief   SENSOR CONTROLLER Accelerometer CB when Tilt is detected\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 static
\f0\b0 \cf3  
\f1\b \cf1 void
\f0\b0 \cf3  lpstkAccelerometerTiltCb(
\f1\b \cf1 void
\f0\b0 \cf3 )\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     Lpstk_Accelerometer accel;\cf0 \
\cf3     uint16_t tempFrameCtrl = configSettings.frameControl;\cf0 \
\cf3     Lpstk_getAccelerometer(&accel);\cf0 \
\cf3     accelerometerSensor.xAxis = accel.x;\cf0 \
\cf3     accelerometerSensor.yAxis = accel.y;\cf0 \
\cf3     accelerometerSensor.zAxis = accel.z;\cf0 \
\cf3     accelerometerSensor.xTiltDet = accel.xTiltDet;\cf0 \
\cf3     accelerometerSensor.yTiltDet = accel.yTiltDet;\cf0 \
\cf3     configSettings.frameControl = Smsgs_dataFields_accelSensor;\cf0 \
\cf3     processSensorMsgEvt();\cf0 \
\cf3     configSettings.frameControl = tempFrameCtrl;\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf3  \cf2 /* LPSTK */\cf0 \
\

\f1\b \cf1 #ifdef
\f0\b0 \cf3  DMM_CENTRAL\cf0 \
\pard\pardeftab720\partightenfactor0
\cf2 /*********************************************************************\cf0 \
\cf2  * @\ul fn\ulnone       Sensor_forwardBleData\cf0 \
\cf2  *\cf0 \
\cf2  * @brief   Forward BLE data to collector\cf0 \
\cf2  */\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 void
\f0\b0 \cf3  Sensor_forwardBleData(
\f1\b \cf1 const
\f0\b0 \cf3  Smsgs_bleSensorField_t *bleInfo)\cf0 \
\pard\pardeftab720\partightenfactor0
\cf3 \{\cf0 \
\cf3     \cf2 // Update sensor data to be sent\cf0 \
\cf3     memcpy(&bleSensor, bleInfo, 
\f1\b \cf1 sizeof
\f0\b0 \cf3 (Smsgs_bleSensorField_t));\cf0 \
\
\cf3     \cf2 // If connected forward BLE sensor data\cf0 \
\cf3     
\f1\b \cf1 if
\f0\b0 \cf3  ((Jdllc_getProvState() == Jdllc_states_joined) ||\cf0 \
\cf3         (Jdllc_getProvState() == Jdllc_states_rejoined))\cf0 \
\cf3     \{\cf0 \
\cf3         \cf2 // Ensure Frame Control is set as \ul Config\ulnone  Messages set frame control to default\cf0 \
\cf3         configSettings.frameControl |= Smsgs_dataFields_bleSensor;\cf0 \
\cf3         processSensorMsgEvt();\cf0 \
\cf3     \}\cf0 \
\cf3 \}\cf0 \
\pard\pardeftab720\partightenfactor0

\f1\b \cf1 #endif
\f0\b0 \cf0 \
}